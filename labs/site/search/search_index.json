{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/00-environment-setup/", 
            "text": "", 
            "title": "Setting up the environment"
        }, 
        {
            "location": "/01-getting-started/", 
            "text": "Getting started with Terraform\n\n\nTerraform Commands\n\n\nYou can check the list of commands for Terraform by running, \n\n\nterrform -h\n\n\nbash-root$ terraform -h\nsage: terraform [--version] [--help] \ncommand\n [args]\n\nThe available commands for execution are listed below.\nThe most common, useful commands are shown first, followed by\nless common or more advanced commands. If you're just getting\nstarted with Terraform, stick with the common commands. For the\nother commands, please read the help and docs before usage.\n\nCommon commands:\n    apply              Builds or changes infrastructure\n    console            Interactive console for Terraform interpolations\n    destroy            Destroy Terraform-managed infrastructure\n    env                Workspace management\n    fmt                Rewrites config files to canonical format\n    get                Download and install modules for the configuration\n    graph              Create a visual graph of Terraform resources\n    import             Import existing infrastructure into Terraform\n    init               Initialize a Terraform working directory\n    output             Read an output from a state file\n    plan               Generate and show an execution plan\n    providers          Prints a tree of the providers used in the configuration\n    push               Upload this Terraform module to Atlas to run\n    refresh            Update local state file against real resources\n    show               Inspect Terraform state or plan\n    taint              Manually mark a resource for recreation\n    untaint            Manually unmark a resource as tainted\n    validate           Validates the Terraform files\n    version            Prints the Terraform version\n    workspace          Workspace management\n\nAll other commands:\n    debug              Debug output management (experimental)\n    force-unlock       Manually unlock the terraform state\n    state              Advanced state management\n\n\n\n\nFrom those commands, the following are important.\n\n\nterraform plan\nterraform apply\nterraform destroy\nterraform init\nterraform fmt\n\n\n\n\nProviders\n\n\nProviders are a way to define where you want to create your infrastructure. Usually Providers are,\n\n\n\n\nIaaS\n\n\nPaaS\n\n\nSaaS\n\n\n\n\nMostly we will be using IaaS providers(Ex: AWS, Azure, GCP, etc.,)\n\n\nEx: AWS Provider\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\n\n\n\nResources\n\n\nResources are the different entities you want to create on given provider. As an example, for AWS provider, if you want to create an EC2 machine, you have to create the following resource.\n\n\nEx: EC2 Resource\n\n\nresource \naws_instance\n \nweb\n {\n  ami           = \nami-04169656fea786776\n\n  instance_type = \nt2.micro\n\n  key_name      = \nschoolofdevops\n\n\n  tags {\n    Name = \nterraform-second-machine\n\n  }\n}", 
            "title": "Getting Started"
        }, 
        {
            "location": "/01-getting-started/#getting-started-with-terraform", 
            "text": "", 
            "title": "Getting started with Terraform"
        }, 
        {
            "location": "/01-getting-started/#terraform-commands", 
            "text": "You can check the list of commands for Terraform by running,   terrform -h  bash-root$ terraform -h\nsage: terraform [--version] [--help]  command  [args]\n\nThe available commands for execution are listed below.\nThe most common, useful commands are shown first, followed by\nless common or more advanced commands. If you're just getting\nstarted with Terraform, stick with the common commands. For the\nother commands, please read the help and docs before usage.\n\nCommon commands:\n    apply              Builds or changes infrastructure\n    console            Interactive console for Terraform interpolations\n    destroy            Destroy Terraform-managed infrastructure\n    env                Workspace management\n    fmt                Rewrites config files to canonical format\n    get                Download and install modules for the configuration\n    graph              Create a visual graph of Terraform resources\n    import             Import existing infrastructure into Terraform\n    init               Initialize a Terraform working directory\n    output             Read an output from a state file\n    plan               Generate and show an execution plan\n    providers          Prints a tree of the providers used in the configuration\n    push               Upload this Terraform module to Atlas to run\n    refresh            Update local state file against real resources\n    show               Inspect Terraform state or plan\n    taint              Manually mark a resource for recreation\n    untaint            Manually unmark a resource as tainted\n    validate           Validates the Terraform files\n    version            Prints the Terraform version\n    workspace          Workspace management\n\nAll other commands:\n    debug              Debug output management (experimental)\n    force-unlock       Manually unlock the terraform state\n    state              Advanced state management  From those commands, the following are important.  terraform plan\nterraform apply\nterraform destroy\nterraform init\nterraform fmt", 
            "title": "Terraform Commands"
        }, 
        {
            "location": "/01-getting-started/#providers", 
            "text": "Providers are a way to define where you want to create your infrastructure. Usually Providers are,   IaaS  PaaS  SaaS   Mostly we will be using IaaS providers(Ex: AWS, Azure, GCP, etc.,)  Ex: AWS Provider  provider  aws  {\n  region =  us-east-1 \n}", 
            "title": "Providers"
        }, 
        {
            "location": "/01-getting-started/#resources", 
            "text": "Resources are the different entities you want to create on given provider. As an example, for AWS provider, if you want to create an EC2 machine, you have to create the following resource.  Ex: EC2 Resource  resource  aws_instance   web  {\n  ami           =  ami-04169656fea786776 \n  instance_type =  t2.micro \n  key_name      =  schoolofdevops \n\n  tags {\n    Name =  terraform-second-machine \n  }\n}", 
            "title": "Resources"
        }, 
        {
            "location": "/02-terraform-important-commands/", 
            "text": "Important Terraform Commands\n\n\nTerraform Plan\n\n\nWhen you run \nterraform plan\n it will present you with the \nexecution plan", 
            "title": "Important Commands"
        }, 
        {
            "location": "/02-terraform-important-commands/#important-terraform-commands", 
            "text": "", 
            "title": "Important Terraform Commands"
        }, 
        {
            "location": "/02-terraform-important-commands/#terraform-plan", 
            "text": "When you run  terraform plan  it will present you with the  execution plan", 
            "title": "Terraform Plan"
        }, 
        {
            "location": "/03-providers/", 
            "text": "Providers\n\n\nIn Terraform, Providers are responsible for understanding API interactions from IaaS(AWS, Azure, etc.,), PaaS(Heroku) or SaaS(CloudFlare, DNSSimple, DNSMadeEasy, etc.,). \n\n\nExample Provider\n\n\nLet's look at AWS Provider as an example.\n\n\nprovider \naws\n {\n  access_key = \n${var.aws_access_key}\n\n  secret_key = \n${var.aws_secret_key}\n\n  region     = \nus-east-1\n\n}\n\n\n\n\nAs seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In our example, we have porvided AWS access key and secret key to perform the same. \n\n\nSetting up our environment for AWS\n\n\nLet us set up our environment by creating a directory called \naws\n.\n\n\nmkdir aws\ncd aws\n\n\n\n\nAfter changing directory into \naws\n, we need to create a file named \nmain.tf\n.\n\n\ntouch main.tf\n\n\n\n\nDefine your Provider details in this main manifest. Change the region if you want to create the resources elsewhere.\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\n\n\n\nExport your AWS access and secret keys as environment variables.\n\n\nexport AWS_ACCESS_KEY_ID=\nAKIAI3NYUWMNORYTDYBC\n\nexport AWS_SECRET_ACCESS_KEY=\ntoOh/ejVKe44wx3ujr7scaehdy4\n\n\n\n\n\nFinally run the following command to initialize your environment.\n\n\nterraform init\n\n[output]\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider \naws\n (1.37.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version = \n...\n constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version = \n~\n 1.37\n\n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running \nterraform plan\n to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.\n\n\n\n\nThis should initialize the environment for our course.\n\n\nReference\n\n\nIf you want to learn more about providers, you can visit \nthis link\n.", 
            "title": "Terraform Providers"
        }, 
        {
            "location": "/03-providers/#providers", 
            "text": "In Terraform, Providers are responsible for understanding API interactions from IaaS(AWS, Azure, etc.,), PaaS(Heroku) or SaaS(CloudFlare, DNSSimple, DNSMadeEasy, etc.,).", 
            "title": "Providers"
        }, 
        {
            "location": "/03-providers/#example-provider", 
            "text": "Let's look at AWS Provider as an example.  provider  aws  {\n  access_key =  ${var.aws_access_key} \n  secret_key =  ${var.aws_secret_key} \n  region     =  us-east-1 \n}  As seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In our example, we have porvided AWS access key and secret key to perform the same.", 
            "title": "Example Provider"
        }, 
        {
            "location": "/03-providers/#setting-up-our-environment-for-aws", 
            "text": "Let us set up our environment by creating a directory called  aws .  mkdir aws\ncd aws  After changing directory into  aws , we need to create a file named  main.tf .  touch main.tf  Define your Provider details in this main manifest. Change the region if you want to create the resources elsewhere.  provider  aws  {\n  region =  us-east-1 \n}  Export your AWS access and secret keys as environment variables.  export AWS_ACCESS_KEY_ID= AKIAI3NYUWMNORYTDYBC \nexport AWS_SECRET_ACCESS_KEY= toOh/ejVKe44wx3ujr7scaehdy4   Finally run the following command to initialize your environment.  terraform init\n\n[output]\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider  aws  (1.37.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version =  ...  constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version =  ~  1.37 \n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running  terraform plan  to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.  This should initialize the environment for our course.", 
            "title": "Setting up our environment for AWS"
        }, 
        {
            "location": "/03-providers/#reference", 
            "text": "If you want to learn more about providers, you can visit  this link .", 
            "title": "Reference"
        }, 
        {
            "location": "/04-resources-part1/", 
            "text": "Resources\n\n\nResources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. To do so, you will have to define them in a terraform manifest and apply them. \n\n\nCreating our first Resource\n\n\nLet us create an EC2 instance, which is going to be our first resource on AWS using Terraform. \n\n\nEvery resorce has the following syntax.\n\n\nresource syntax\n\n\nresource \nresource_type\n \nresource_name\n {\n  config1 = value1\n  config2 = value2\n}\n\n\n\n\nHere, \n  resource_type = The type of the resouce that we create/delete/modfiy\n  resource_name = Give the resource a name for Terraform internal references.\n  config(1-n)   = The properties of the reosurce your manipulating.\n\n\nIn your main.tf, add this block next to your Provider definition. \n\n\nan ec2 resource\n\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n}\n\n\n\n\nHere, to compare it with the syntax,\n  resource_type = aws_instance\n  resource_name = webserver\n  config1       = ami\n  value1        = ami-408c7f28(ubuntu-14.04)\n  config2       = instance_type\n  value2        = t1.micro\n\n\nYour \nmain.tf\n file should look like the following. \n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n}\n\n\n\n\nTerraform Plan\n\n\nThen run \nterraform plan\n to see what will happen if we apply the manifest.\n\n\nterraform plan\n\n[output]\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\nTerraform will perform the following actions:\n\n  + aws_instance.webserver\n      id:                           \ncomputed\n\n      ami:                          \nami-408c7f28\n\n      arn:                          \ncomputed\n\n      associate_public_ip_address:  \ncomputed\n\n      availability_zone:            \ncomputed\n\n      cpu_core_count:               \ncomputed\n\n      cpu_threads_per_core:         \ncomputed\n\n      ebs_block_device.#:           \ncomputed\n\n      ephemeral_block_device.#:     \ncomputed\n\n      get_password_data:            \nfalse\n\n      instance_state:               \ncomputed\n\n      instance_type:                \nt1.micro\n\n[...]\n\nPlan: 1 to add, 0 to change, 0 to destroy.\n\n------------------------------------------------------------------------\n\nNote: You didn't specify an \n-out\n parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if\n\nterraform apply\n is subsequently run.\n\n\n\n\nTerraform Apply\n\n\nThen run, \nterraform apply\n to actually create the resource on AWS.\n\n\nterraform apply\n\n[output]\n[...]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Creation complete after 49s (ID: i-02489cdf638f05bbd)\n\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.\n\n\n\n\nWe have successfully created our first reosource on AWS. Please check your AWS console to check the properties(AMI and instance type) of the machine.\n\n\n\n\nReference\n\n\nIf you need further details about resources, please visit this \nlink", 
            "title": "Terraform Building Blocks - Part 1"
        }, 
        {
            "location": "/04-resources-part1/#resources", 
            "text": "Resources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. To do so, you will have to define them in a terraform manifest and apply them.", 
            "title": "Resources"
        }, 
        {
            "location": "/04-resources-part1/#creating-our-first-resource", 
            "text": "Let us create an EC2 instance, which is going to be our first resource on AWS using Terraform.   Every resorce has the following syntax.  resource syntax  resource  resource_type   resource_name  {\n  config1 = value1\n  config2 = value2\n}  Here, \n  resource_type = The type of the resouce that we create/delete/modfiy\n  resource_name = Give the resource a name for Terraform internal references.\n  config(1-n)   = The properties of the reosurce your manipulating.  In your main.tf, add this block next to your Provider definition.   an ec2 resource  resource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n}  Here, to compare it with the syntax,\n  resource_type = aws_instance\n  resource_name = webserver\n  config1       = ami\n  value1        = ami-408c7f28(ubuntu-14.04)\n  config2       = instance_type\n  value2        = t1.micro  Your  main.tf  file should look like the following.   provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n}", 
            "title": "Creating our first Resource"
        }, 
        {
            "location": "/04-resources-part1/#terraform-plan", 
            "text": "Then run  terraform plan  to see what will happen if we apply the manifest.  terraform plan\n\n[output]\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\nTerraform will perform the following actions:\n\n  + aws_instance.webserver\n      id:                            computed \n      ami:                           ami-408c7f28 \n      arn:                           computed \n      associate_public_ip_address:   computed \n      availability_zone:             computed \n      cpu_core_count:                computed \n      cpu_threads_per_core:          computed \n      ebs_block_device.#:            computed \n      ephemeral_block_device.#:      computed \n      get_password_data:             false \n      instance_state:                computed \n      instance_type:                 t1.micro \n[...]\n\nPlan: 1 to add, 0 to change, 0 to destroy.\n\n------------------------------------------------------------------------\n\nNote: You didn't specify an  -out  parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if terraform apply  is subsequently run.", 
            "title": "Terraform Plan"
        }, 
        {
            "location": "/04-resources-part1/#terraform-apply", 
            "text": "Then run,  terraform apply  to actually create the resource on AWS.  terraform apply\n\n[output]\n[...]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Creation complete after 49s (ID: i-02489cdf638f05bbd)\n\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.  We have successfully created our first reosource on AWS. Please check your AWS console to check the properties(AMI and instance type) of the machine.", 
            "title": "Terraform Apply"
        }, 
        {
            "location": "/04-resources-part1/#reference", 
            "text": "If you need further details about resources, please visit this  link", 
            "title": "Reference"
        }, 
        {
            "location": "/05-resources-part2/", 
            "text": "Variables and Outputs\n\n\nThe ec2 instance that we have created is not that useful when we don't have access to it. So let us delete it and  we shall set up this again with additional resources. \n\n\nLet us create a security group, which allows us to ssh(port 22) into the machine.\n\n\nfile: main.tf\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n}\n\nresource \naws_security_group\n \nwebserver_sg\n {\n\n    name = \nwebserver-sg\n\n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    = \ntcp\n\n        cidr_blocks = [\n0.0.0.0/0\n]\n    }\n}\n\n\n\n\nHere,\n  Resource type = aws_security_group,\n  Resource name = webserver_sg\n\n\nThis \naws_security_group\n resource allows us to ssh into the instance.\n\n\nWe need to create the EC2 instance with this security group. To do that, \n\n\nThe final requirement is a \nkey pair\n using which we can login to the machine. Let us use \naws_key_pair\n to register the key with AWS and then use in our ec2 instance.\n\n\nTo do this, you will need to create a key pair in your local machine. Run the following commands. This will create one public key and a private key.\n\n\nroot@vibe$ ssh-keygen -t rsa\n\n[output]\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/vibe/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/vibe/.ssh/id_rsa.\nYour public key has been saved in /home/vibe/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:nSnSLKDvnLv22LFX+wKYMa0TvSt3AL406z+Asj/GSak vibe@vibes-MacBook-Air.local\nThe key's randomart image is:\n+---[RSA 2048]----+\n|                 |\n|                 |\n|    .  o         |\n|   . .=oo. o     |\n|  .  +oOS.+      |\n|  ..+ Xo+..      |\n|   *.o.* = .     |\n|  Eo*++o= +      |\n|   +O*==.o o.    |\n+----[SHA256]-----+\n\n\n\n\nCopy the content of your public key\n\n\ncat ~/.ssh/id_rsa.pub\n\n[output]\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n\n\n\nPaste the content of public key in the public_key\n\n\nfile: main.tf\n\n\n[...]\n\nresource \naws_security_group\n \nwebserver_sg\n {\n\n    name = \nwebserver-sg\n\n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    = \ntcp\n\n        cidr_blocks = [\n0.0.0.0/0\n]\n    }\n}\n\nresource \naws_key_pair\n \nwebserver_key\n {\n  key_name   = \nweb-admin-key\n\n  public_key = \nssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n}\n\n\n\n\nWe need to make sure our instance uses this key. To do that, we should add one more attribute to our \naws_instance\n module. We will also tag the instace with a name.\n\n\nfile: main.tf\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n  key_name      = \nweb-admin-key\n\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n\n[...]\n\n\n\n\nThe final file shoudl look like the following.\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n  key_name      = \nweb-admin-key\n\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n\nresource \naws_security_group\n \nwebserver_sg\n {\n\n        name = \nwebserver-sg\n\n\n        ingress {\n                from_port   = 22\n                to_port     = 22\n                protocol    = \ntcp\n\n                cidr_blocks = [\n0.0.0.0/0\n]\n        }\n}\n\nresource \naws_key_pair\n \nwebserver_key\n {\n  key_name   = \nweb-admin-key\n\n  public_key = \nssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n}\n\n\n\n\nExplicit Dependency\n\n\nWhen we apply the manifest, we will get the following error.\n\n\nterraform apply\n\n[output]\naws_security_group.webserver_sg: Still creating... (10s elapsed)\naws_security_group.webserver_sg: Creation complete after 11s (ID: sg-0c22a3497351d1caa)\n\nError: Error applying plan:\n\n2 error(s) occurred:\n\n* aws_instance.webserver: 1 error(s) occurred:\n\n* aws_instance.webserver: Error launching source instance: InvalidKeyPair.NotFound: The key pair 'web-admin-key' does not exist\n    status code: 400, request id: 36af6c0c-9016-4dc4-bd3a-7b94fc3dfade\n* aws_key_pair.webserver_key: 1 error(s) occurred:\n\n* aws_key_pair.webserver_key: Error import KeyPair: InvalidKey.Format: Key is not in valid OpenSSH public key format\n    status code: 400, request id: 8a3697d2-4450-4150-86e0-3b75c0d43b80\n\nTerraform does not automatically rollback in the face of errors.\nInstead, your Terraform state file has been partially updated with\nany resources that successfully completed. Please address the error\nabove and apply again to incrementally change your infrastructure.\n\n\n\n\nThis is because, the ec2 resource tries to use the key even before it is created. We can control the order of execution in two ways.\n  1. Implicit Dependecy (Automatic Dependency)\n  2. Explicit Dependency (Manual Dependency)\n\n\nWe will learn more about \nImplicit Dependency\n in the next chapter. Now we will focus on adding \nExplicit Dependency\n to \naws_instance\n resource to depend on \naws_key_pair\n resource.\n\n\nThis will guarantee the creation of key pair before the instance get's created. In your instance block add the following,\n\n\nfile: main.tf\n\n\n[...]\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n  key_name      = \nweb-admin-key\n\n\n  depends_on = [\naws_key_pair.webserver_key\n]\n  tags {\n    Name = \nweberserver\n\n  }\n}\n[...]\n\n\n\n\nSyntax: \ndepends_on = [\"resource_type.resource_name\"]\n\n\nIdempotency\n\n\nFinally apply the manifest by running,\n\n\nterraform apply\n\n[output]\nPlan: 2 to add, 0 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_key_pair.webserver_key: Creating...\n  fingerprint: \n =\n \ncomputed\n\n  key_name:    \n =\n \nweb-admin-key\n\n  public_key:  \n =\n \nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\naws_key_pair.webserver_key: Creation complete after 3s (ID: web-admin-key)\naws_instance.webserver: Creating...\n  ami:                          \n =\n \nami-408c7f28\n\n  arn:                          \n =\n \ncomputed\n\n  associate_public_ip_address:  \n =\n \ncomputed\n\n  availability_zone:            \n =\n \ncomputed\n\n  cpu_core_count:               \n =\n \ncomputed\n\n  cpu_threads_per_core:         \n =\n \ncomputed\n\n  ebs_block_device.#:           \n =\n \ncomputed\n\n  ephemeral_block_device.#:     \n =\n \ncomputed\n\n  get_password_data:            \n =\n \nfalse\n\n  instance_state:               \n =\n \ncomputed\n\n  instance_type:                \n =\n \nt1.micro\n\n  ipv6_address_count:           \n =\n \ncomputed\n\n  ipv6_addresses.#:             \n =\n \ncomputed\n\n  key_name:                     \n =\n \nweb-admin-key\n\n  network_interface.#:          \n =\n \ncomputed\n\n  network_interface_id:         \n =\n \ncomputed\n\n  password_data:                \n =\n \ncomputed\n\n  placement_group:              \n =\n \ncomputed\n\n  primary_network_interface_id: \n =\n \ncomputed\n\n  private_dns:                  \n =\n \ncomputed\n\n  private_ip:                   \n =\n \ncomputed\n\n  public_dns:                   \n =\n \ncomputed\n\n  public_ip:                    \n =\n \ncomputed\n\n  root_block_device.#:          \n =\n \ncomputed\n\n  security_groups.#:            \n =\n \ncomputed\n\n  source_dest_check:            \n =\n \ntrue\n\n  subnet_id:                    \n =\n \ncomputed\n\n  tags.%:                       \n =\n \n1\n\n  tags.Name:                    \n =\n \nweberserver\n\n  tenancy:                      \n =\n \ncomputed\n\n  volume_tags.%:                \n =\n \ncomputed\n\n  vpc_security_group_ids.#:     \n =\n \ncomputed\n\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Creation complete after 37s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 2 added, 0 changed, 0 destroyed.\n\n\n\n\nIf you have noticed, Terraform did not create the security group this time around. The reason for this behaviour is, it had created the security group resource in the first run itself. So it did not create the same resource again when we applied the second time. This behaviour is called \nIdempotency\n.", 
            "title": "Terraform Building Blocks - Part 2"
        }, 
        {
            "location": "/05-resources-part2/#variables-and-outputs", 
            "text": "The ec2 instance that we have created is not that useful when we don't have access to it. So let us delete it and  we shall set up this again with additional resources.   Let us create a security group, which allows us to ssh(port 22) into the machine.  file: main.tf  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n}\n\nresource  aws_security_group   webserver_sg  {\n\n    name =  webserver-sg \n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    =  tcp \n        cidr_blocks = [ 0.0.0.0/0 ]\n    }\n}  Here,\n  Resource type = aws_security_group,\n  Resource name = webserver_sg  This  aws_security_group  resource allows us to ssh into the instance.  We need to create the EC2 instance with this security group. To do that,   The final requirement is a  key pair  using which we can login to the machine. Let us use  aws_key_pair  to register the key with AWS and then use in our ec2 instance.  To do this, you will need to create a key pair in your local machine. Run the following commands. This will create one public key and a private key.  root@vibe$ ssh-keygen -t rsa\n\n[output]\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/vibe/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/vibe/.ssh/id_rsa.\nYour public key has been saved in /home/vibe/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:nSnSLKDvnLv22LFX+wKYMa0TvSt3AL406z+Asj/GSak vibe@vibes-MacBook-Air.local\nThe key's randomart image is:\n+---[RSA 2048]----+\n|                 |\n|                 |\n|    .  o         |\n|   . .=oo. o     |\n|  .  +oOS.+      |\n|  ..+ Xo+..      |\n|   *.o.* = .     |\n|  Eo*++o= +      |\n|   +O*==.o o.    |\n+----[SHA256]-----+  Copy the content of your public key  cat ~/.ssh/id_rsa.pub\n\n[output]\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local  Paste the content of public key in the public_key  file: main.tf  [...]\n\nresource  aws_security_group   webserver_sg  {\n\n    name =  webserver-sg \n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    =  tcp \n        cidr_blocks = [ 0.0.0.0/0 ]\n    }\n}\n\nresource  aws_key_pair   webserver_key  {\n  key_name   =  web-admin-key \n  public_key =  ssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n}  We need to make sure our instance uses this key. To do that, we should add one more attribute to our  aws_instance  module. We will also tag the instace with a name.  file: main.tf  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n  key_name      =  web-admin-key \n\n  tags {\n    Name =  weberserver \n  }\n}\n\n[...]  The final file shoudl look like the following.  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n  key_name      =  web-admin-key \n\n  tags {\n    Name =  weberserver \n  }\n}\n\nresource  aws_security_group   webserver_sg  {\n\n        name =  webserver-sg \n\n        ingress {\n                from_port   = 22\n                to_port     = 22\n                protocol    =  tcp \n                cidr_blocks = [ 0.0.0.0/0 ]\n        }\n}\n\nresource  aws_key_pair   webserver_key  {\n  key_name   =  web-admin-key \n  public_key =  ssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \n}", 
            "title": "Variables and Outputs"
        }, 
        {
            "location": "/05-resources-part2/#explicit-dependency", 
            "text": "When we apply the manifest, we will get the following error.  terraform apply\n\n[output]\naws_security_group.webserver_sg: Still creating... (10s elapsed)\naws_security_group.webserver_sg: Creation complete after 11s (ID: sg-0c22a3497351d1caa)\n\nError: Error applying plan:\n\n2 error(s) occurred:\n\n* aws_instance.webserver: 1 error(s) occurred:\n\n* aws_instance.webserver: Error launching source instance: InvalidKeyPair.NotFound: The key pair 'web-admin-key' does not exist\n    status code: 400, request id: 36af6c0c-9016-4dc4-bd3a-7b94fc3dfade\n* aws_key_pair.webserver_key: 1 error(s) occurred:\n\n* aws_key_pair.webserver_key: Error import KeyPair: InvalidKey.Format: Key is not in valid OpenSSH public key format\n    status code: 400, request id: 8a3697d2-4450-4150-86e0-3b75c0d43b80\n\nTerraform does not automatically rollback in the face of errors.\nInstead, your Terraform state file has been partially updated with\nany resources that successfully completed. Please address the error\nabove and apply again to incrementally change your infrastructure.  This is because, the ec2 resource tries to use the key even before it is created. We can control the order of execution in two ways.\n  1. Implicit Dependecy (Automatic Dependency)\n  2. Explicit Dependency (Manual Dependency)  We will learn more about  Implicit Dependency  in the next chapter. Now we will focus on adding  Explicit Dependency  to  aws_instance  resource to depend on  aws_key_pair  resource.  This will guarantee the creation of key pair before the instance get's created. In your instance block add the following,  file: main.tf  [...]\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n  key_name      =  web-admin-key \n\n  depends_on = [ aws_key_pair.webserver_key ]\n  tags {\n    Name =  weberserver \n  }\n}\n[...]  Syntax:  depends_on = [\"resource_type.resource_name\"]", 
            "title": "Explicit Dependency"
        }, 
        {
            "location": "/05-resources-part2/#idempotency", 
            "text": "Finally apply the manifest by running,  terraform apply\n\n[output]\nPlan: 2 to add, 0 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_key_pair.webserver_key: Creating...\n  fingerprint:   =   computed \n  key_name:      =   web-admin-key \n  public_key:    =   ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \naws_key_pair.webserver_key: Creation complete after 3s (ID: web-admin-key)\naws_instance.webserver: Creating...\n  ami:                            =   ami-408c7f28 \n  arn:                            =   computed \n  associate_public_ip_address:    =   computed \n  availability_zone:              =   computed \n  cpu_core_count:                 =   computed \n  cpu_threads_per_core:           =   computed \n  ebs_block_device.#:             =   computed \n  ephemeral_block_device.#:       =   computed \n  get_password_data:              =   false \n  instance_state:                 =   computed \n  instance_type:                  =   t1.micro \n  ipv6_address_count:             =   computed \n  ipv6_addresses.#:               =   computed \n  key_name:                       =   web-admin-key \n  network_interface.#:            =   computed \n  network_interface_id:           =   computed \n  password_data:                  =   computed \n  placement_group:                =   computed \n  primary_network_interface_id:   =   computed \n  private_dns:                    =   computed \n  private_ip:                     =   computed \n  public_dns:                     =   computed \n  public_ip:                      =   computed \n  root_block_device.#:            =   computed \n  security_groups.#:              =   computed \n  source_dest_check:              =   true \n  subnet_id:                      =   computed \n  tags.%:                         =   1 \n  tags.Name:                      =   weberserver \n  tenancy:                        =   computed \n  volume_tags.%:                  =   computed \n  vpc_security_group_ids.#:       =   computed \naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Creation complete after 37s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 2 added, 0 changed, 0 destroyed.  If you have noticed, Terraform did not create the security group this time around. The reason for this behaviour is, it had created the security group resource in the first run itself. So it did not create the same resource again when we applied the second time. This behaviour is called  Idempotency .", 
            "title": "Idempotency"
        }, 
        {
            "location": "/06-terraform-state/", 
            "text": "Terraform State\n\n\nOne advantage, Terraform has over other configuration management tools like Ansible and Chef is State management. Terraform stores all our infrastructure information(that we have created using Terraform) in a file with the name \nterraform.tfstate\n. \n\n\nIn the last chapter, we have ran \nterraform apply\n. This command would create the above mentioned JSON flavoured statefile. Let us look at its the content.\n\n\nterraform.tfstate\n\n\n{\n    \nversion\n: 3,\n    \nterraform_version\n: \n0.11.7\n,\n    \nserial\n: 1,\n    \nlineage\n: \n138bb0c6-ca69-0d39-aa90-5e08f29c8efb\n,\n    \nmodules\n: [\n        {\n            \npath\n: [\n                \nroot\n\n            ],\n            \noutputs\n: {},\n            \nresources\n: {\n                \naws_instance.webserver\n: {\n                    \ntype\n: \naws_instance\n,\n                    \ndepends_on\n: [],\n                    \nprimary\n: {\n                        \nid\n: \ni-02489cdf638f05bbd\n,\n                        \nattributes\n: {\n                            \nami\n: \nami-408c7f28\n,\n                            \narn\n: \narn:aws:ec2:us-east-1:822941572458:instance/i-02489cdf638f05bbd\n,\n                            \nassociate_public_ip_address\n: \ntrue\n,\n                            \navailability_zone\n: \nus-east-1d\n,\n                            \ncpu_core_count\n: \n1\n,\n                            \ncpu_threads_per_core\n: \n1\n,\n                            \ncredit_specification.#\n: \n1\n,\n                            \ncredit_specification.0.cpu_credits\n: \nstandard\n,\n                            \ndisable_api_termination\n: \nfalse\n,\n                            \nebs_block_device.#\n: \n0\n,\n                            \nebs_optimized\n: \nfalse\n,\n                            \nephemeral_block_device.#\n: \n0\n,\n                            \nget_password_data\n: \nfalse\n,\n                            \niam_instance_profile\n: \n,\n                            \nid\n: \ni-02489cdf638f05bbd\n,\n                            \ninstance_state\n: \nrunning\n,\n                            \ninstance_type\n: \nt1.micro\n,\n                            \nipv6_addresses.#\n: \n0\n,\n                            \nkey_name\n: \n,\n                            \nmonitoring\n: \nfalse\n,\n                            \nnetwork_interface.#\n: \n0\n,\n                            \nnetwork_interface_id\n: \neni-00fbc08209349bb38\n,\n                            \npassword_data\n: \n,\n                            \nplacement_group\n: \n,\n                            \nprimary_network_interface_id\n: \neni-00fbc08209349bb38\n,\n                            \nprivate_dns\n: \nip-172-31-24-184.ec2.internal\n,\n                            \nprivate_ip\n: \n172.31.24.184\n,\n                            \npublic_dns\n: \nec2-34-230-78-138.compute-1.amazonaws.com\n,\n                            \npublic_ip\n: \n34.230.78.138\n,\n                            \nroot_block_device.#\n: \n1\n,\n                            \nroot_block_device.0.delete_on_termination\n: \ntrue\n,\n                            \nroot_block_device.0.iops\n: \n0\n,\n                            \nroot_block_device.0.volume_id\n: \nvol-0cc495c189e5c8dd2\n,\n                            \nroot_block_device.0.volume_size\n: \n8\n,\n                            \nroot_block_device.0.volume_type\n: \nstandard\n,\n                            \nsecurity_groups.#\n: \n1\n,\n                            \nsecurity_groups.3814588639\n: \ndefault\n,\n                            \nsource_dest_check\n: \ntrue\n,\n                            \nsubnet_id\n: \nsubnet-e8b3e6a2\n,\n                            \ntags.%\n: \n0\n,\n                            \ntenancy\n: \ndefault\n,\n                            \nvolume_tags.%\n: \n0\n,\n                            \nvpc_security_group_ids.#\n: \n1\n,\n                            \nvpc_security_group_ids.3314100969\n: \nsg-a42b7ae9\n\n                        },\n                        \nmeta\n: {\n                            \ne2bfb730-ecaa-11e6-8f88-34363bc7c4c0\n: {\n                                \ncreate\n: 600000000000,\n                                \ndelete\n: 1200000000000,\n                                \nupdate\n: 600000000000\n                            },\n                            \nschema_version\n: \n1\n\n                        },\n                        \ntainted\n: false\n                    },\n                    \ndeposed\n: [],\n                    \nprovider\n: \nprovider.aws\n\n                }\n            },\n            \ndepends_on\n: []\n        }\n    ]\n}\n\n\n\n\nUsecase 1\n\n\nThis file contains the metadata of our ec2 instance that we have created in the last chapter. This information will be critical when we have to create \nother resources which references this\n ec2 instance. As we add more resources to the terrform template, this file will get populated with more metadata about each resource.\n\n\nUsecase 2\n\n\nWhat happens when someone manually changes(which is not desirable) the properties of the instance created by Terraform? We can undo the manual changes just by running \nterraform apply\n again. One point to keep in mind though is, some property changes forces resource recreation which might result in data loss.\n\n\nChanges in Terrfaform state\n\n\nLet us see what happens to tfstate file when we destroy the ec2 instance\n\n\nterraform destroy\n\n[output]\naws_instance.webserver: Refreshing state... (ID: i-02489cdf638f05bbd)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n\nPlan: 0 to add, 0 to change, 1 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]\naws_instance.webserver: Still destroying... (ID: i-02489cdf638f05bbd, 1m0s elapsed)\naws_instance.webserver: Destruction complete after 1m0s\n\nDestroy complete! Resources: 1 destroyed.\n\n\n\n\nfile: terraform.tfstate\n\n\n{\n    \nversion\n: 3,\n    \nterraform_version\n: \n0.11.7\n,\n    \nserial\n: 2,\n    \nlineage\n: \n138bb0c6-ca69-0d39-aa90-5e08f29c8efb\n,\n    \nmodules\n: [\n        {\n            \npath\n: [\n                \nroot\n\n            ],\n            \noutputs\n: {},\n            \nresources\n: {},\n            \ndepends_on\n: []\n        }\n    ]\n}\n\n\n\n\nOnce the machine is destroyed, all metadata about that machine is also gone.", 
            "title": "State Management in Terraform"
        }, 
        {
            "location": "/06-terraform-state/#terraform-state", 
            "text": "One advantage, Terraform has over other configuration management tools like Ansible and Chef is State management. Terraform stores all our infrastructure information(that we have created using Terraform) in a file with the name  terraform.tfstate .   In the last chapter, we have ran  terraform apply . This command would create the above mentioned JSON flavoured statefile. Let us look at its the content.  terraform.tfstate  {\n     version : 3,\n     terraform_version :  0.11.7 ,\n     serial : 1,\n     lineage :  138bb0c6-ca69-0d39-aa90-5e08f29c8efb ,\n     modules : [\n        {\n             path : [\n                 root \n            ],\n             outputs : {},\n             resources : {\n                 aws_instance.webserver : {\n                     type :  aws_instance ,\n                     depends_on : [],\n                     primary : {\n                         id :  i-02489cdf638f05bbd ,\n                         attributes : {\n                             ami :  ami-408c7f28 ,\n                             arn :  arn:aws:ec2:us-east-1:822941572458:instance/i-02489cdf638f05bbd ,\n                             associate_public_ip_address :  true ,\n                             availability_zone :  us-east-1d ,\n                             cpu_core_count :  1 ,\n                             cpu_threads_per_core :  1 ,\n                             credit_specification.# :  1 ,\n                             credit_specification.0.cpu_credits :  standard ,\n                             disable_api_termination :  false ,\n                             ebs_block_device.# :  0 ,\n                             ebs_optimized :  false ,\n                             ephemeral_block_device.# :  0 ,\n                             get_password_data :  false ,\n                             iam_instance_profile :  ,\n                             id :  i-02489cdf638f05bbd ,\n                             instance_state :  running ,\n                             instance_type :  t1.micro ,\n                             ipv6_addresses.# :  0 ,\n                             key_name :  ,\n                             monitoring :  false ,\n                             network_interface.# :  0 ,\n                             network_interface_id :  eni-00fbc08209349bb38 ,\n                             password_data :  ,\n                             placement_group :  ,\n                             primary_network_interface_id :  eni-00fbc08209349bb38 ,\n                             private_dns :  ip-172-31-24-184.ec2.internal ,\n                             private_ip :  172.31.24.184 ,\n                             public_dns :  ec2-34-230-78-138.compute-1.amazonaws.com ,\n                             public_ip :  34.230.78.138 ,\n                             root_block_device.# :  1 ,\n                             root_block_device.0.delete_on_termination :  true ,\n                             root_block_device.0.iops :  0 ,\n                             root_block_device.0.volume_id :  vol-0cc495c189e5c8dd2 ,\n                             root_block_device.0.volume_size :  8 ,\n                             root_block_device.0.volume_type :  standard ,\n                             security_groups.# :  1 ,\n                             security_groups.3814588639 :  default ,\n                             source_dest_check :  true ,\n                             subnet_id :  subnet-e8b3e6a2 ,\n                             tags.% :  0 ,\n                             tenancy :  default ,\n                             volume_tags.% :  0 ,\n                             vpc_security_group_ids.# :  1 ,\n                             vpc_security_group_ids.3314100969 :  sg-a42b7ae9 \n                        },\n                         meta : {\n                             e2bfb730-ecaa-11e6-8f88-34363bc7c4c0 : {\n                                 create : 600000000000,\n                                 delete : 1200000000000,\n                                 update : 600000000000\n                            },\n                             schema_version :  1 \n                        },\n                         tainted : false\n                    },\n                     deposed : [],\n                     provider :  provider.aws \n                }\n            },\n             depends_on : []\n        }\n    ]\n}", 
            "title": "Terraform State"
        }, 
        {
            "location": "/06-terraform-state/#usecase-1", 
            "text": "This file contains the metadata of our ec2 instance that we have created in the last chapter. This information will be critical when we have to create  other resources which references this  ec2 instance. As we add more resources to the terrform template, this file will get populated with more metadata about each resource.", 
            "title": "Usecase 1"
        }, 
        {
            "location": "/06-terraform-state/#usecase-2", 
            "text": "What happens when someone manually changes(which is not desirable) the properties of the instance created by Terraform? We can undo the manual changes just by running  terraform apply  again. One point to keep in mind though is, some property changes forces resource recreation which might result in data loss.", 
            "title": "Usecase 2"
        }, 
        {
            "location": "/06-terraform-state/#changes-in-terrfaform-state", 
            "text": "Let us see what happens to tfstate file when we destroy the ec2 instance  terraform destroy\n\n[output]\naws_instance.webserver: Refreshing state... (ID: i-02489cdf638f05bbd)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n\nPlan: 0 to add, 0 to change, 1 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]\naws_instance.webserver: Still destroying... (ID: i-02489cdf638f05bbd, 1m0s elapsed)\naws_instance.webserver: Destruction complete after 1m0s\n\nDestroy complete! Resources: 1 destroyed.  file: terraform.tfstate  {\n     version : 3,\n     terraform_version :  0.11.7 ,\n     serial : 2,\n     lineage :  138bb0c6-ca69-0d39-aa90-5e08f29c8efb ,\n     modules : [\n        {\n             path : [\n                 root \n            ],\n             outputs : {},\n             resources : {},\n             depends_on : []\n        }\n    ]\n}  Once the machine is destroyed, all metadata about that machine is also gone.", 
            "title": "Changes in Terrfaform state"
        }
    ]
}
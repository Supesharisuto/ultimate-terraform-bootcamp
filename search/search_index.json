{
    "docs": [
        {
            "location": "/", 
            "text": "Welcome to MkDocs\n\n\nFor full documentation visit \nmkdocs.org\n.\n\n\nCommands\n\n\n\n\nmkdocs new [dir-name]\n - Create a new project.\n\n\nmkdocs serve\n - Start the live-reloading docs server.\n\n\nmkdocs build\n - Build the documentation site.\n\n\nmkdocs help\n - Print this help message.\n\n\n\n\nProject layout\n\n\nmkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Home"
        }, 
        {
            "location": "/#welcome-to-mkdocs", 
            "text": "For full documentation visit  mkdocs.org .", 
            "title": "Welcome to MkDocs"
        }, 
        {
            "location": "/#commands", 
            "text": "mkdocs new [dir-name]  - Create a new project.  mkdocs serve  - Start the live-reloading docs server.  mkdocs build  - Build the documentation site.  mkdocs help  - Print this help message.", 
            "title": "Commands"
        }, 
        {
            "location": "/#project-layout", 
            "text": "mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.", 
            "title": "Project layout"
        }, 
        {
            "location": "/00-environment-setup/", 
            "text": "", 
            "title": "Setting up the environment"
        }, 
        {
            "location": "/01-getting-started/", 
            "text": "Getting started with Terraform\n\n\nTerraform Commands\n\n\nYou can check the list of commands for Terraform by running, \n\n\nterrform -h\n\n\nbash-root$ terraform -h\nsage: terraform [--version] [--help] \ncommand\n [args]\n\nThe available commands for execution are listed below.\nThe most common, useful commands are shown first, followed by\nless common or more advanced commands. If you're just getting\nstarted with Terraform, stick with the common commands. For the\nother commands, please read the help and docs before usage.\n\nCommon commands:\n    apply              Builds or changes infrastructure\n    console            Interactive console for Terraform interpolations\n    destroy            Destroy Terraform-managed infrastructure\n    env                Workspace management\n    fmt                Rewrites config files to canonical format\n    get                Download and install modules for the configuration\n    graph              Create a visual graph of Terraform resources\n    import             Import existing infrastructure into Terraform\n    init               Initialize a Terraform working directory\n    output             Read an output from a state file\n    plan               Generate and show an execution plan\n    providers          Prints a tree of the providers used in the configuration\n    push               Upload this Terraform module to Atlas to run\n    refresh            Update local state file against real resources\n    show               Inspect Terraform state or plan\n    taint              Manually mark a resource for recreation\n    untaint            Manually unmark a resource as tainted\n    validate           Validates the Terraform files\n    version            Prints the Terraform version\n    workspace          Workspace management\n\nAll other commands:\n    debug              Debug output management (experimental)\n    force-unlock       Manually unlock the terraform state\n    state              Advanced state management\n\n\n\n\nFrom those commands, the following are important.\n\n\nterraform plan\nterraform apply\nterraform destroy\nterraform init\nterraform fmt\n\n\n\n\nProviders\n\n\nProviders are a way to define where you want to create your infrastructure. Usually Providers are,\n\n\n\n\nIaaS\n\n\nPaaS\n\n\nSaaS\n\n\n\n\nMostly we will be using IaaS providers(Ex: AWS, Azure, GCP, etc.,)\n\n\nEx: AWS Provider\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\n\n\n\nResources\n\n\nResources are the different entities you want to create on given provider. As an example, for AWS provider, if you want to create an EC2 machine, you have to create the following resource.\n\n\nEx: EC2 Resource\n\n\nresource \naws_instance\n \nweb\n {\n  ami           = \nami-04169656fea786776\n\n  instance_type = \nt2.micro\n\n  key_name      = \nschoolofdevops\n\n\n  tags {\n    Name = \nterraform-second-machine\n\n  }\n}", 
            "title": "Getting Started"
        }, 
        {
            "location": "/01-getting-started/#getting-started-with-terraform", 
            "text": "", 
            "title": "Getting started with Terraform"
        }, 
        {
            "location": "/01-getting-started/#terraform-commands", 
            "text": "You can check the list of commands for Terraform by running,   terrform -h  bash-root$ terraform -h\nsage: terraform [--version] [--help]  command  [args]\n\nThe available commands for execution are listed below.\nThe most common, useful commands are shown first, followed by\nless common or more advanced commands. If you're just getting\nstarted with Terraform, stick with the common commands. For the\nother commands, please read the help and docs before usage.\n\nCommon commands:\n    apply              Builds or changes infrastructure\n    console            Interactive console for Terraform interpolations\n    destroy            Destroy Terraform-managed infrastructure\n    env                Workspace management\n    fmt                Rewrites config files to canonical format\n    get                Download and install modules for the configuration\n    graph              Create a visual graph of Terraform resources\n    import             Import existing infrastructure into Terraform\n    init               Initialize a Terraform working directory\n    output             Read an output from a state file\n    plan               Generate and show an execution plan\n    providers          Prints a tree of the providers used in the configuration\n    push               Upload this Terraform module to Atlas to run\n    refresh            Update local state file against real resources\n    show               Inspect Terraform state or plan\n    taint              Manually mark a resource for recreation\n    untaint            Manually unmark a resource as tainted\n    validate           Validates the Terraform files\n    version            Prints the Terraform version\n    workspace          Workspace management\n\nAll other commands:\n    debug              Debug output management (experimental)\n    force-unlock       Manually unlock the terraform state\n    state              Advanced state management  From those commands, the following are important.  terraform plan\nterraform apply\nterraform destroy\nterraform init\nterraform fmt", 
            "title": "Terraform Commands"
        }, 
        {
            "location": "/01-getting-started/#providers", 
            "text": "Providers are a way to define where you want to create your infrastructure. Usually Providers are,   IaaS  PaaS  SaaS   Mostly we will be using IaaS providers(Ex: AWS, Azure, GCP, etc.,)  Ex: AWS Provider  provider  aws  {\n  region =  us-east-1 \n}", 
            "title": "Providers"
        }, 
        {
            "location": "/01-getting-started/#resources", 
            "text": "Resources are the different entities you want to create on given provider. As an example, for AWS provider, if you want to create an EC2 machine, you have to create the following resource.  Ex: EC2 Resource  resource  aws_instance   web  {\n  ami           =  ami-04169656fea786776 \n  instance_type =  t2.micro \n  key_name      =  schoolofdevops \n\n  tags {\n    Name =  terraform-second-machine \n  }\n}", 
            "title": "Resources"
        }, 
        {
            "location": "/02-terraform-important-commands/", 
            "text": "Important Terraform Commands\n\n\nTerraform Plan\n\n\nWhen you run \nterraform plan\n it will present you with the \nexecution plan\n. This will show you which resources are going to be created/deleted or modified. This is more like a dry run, if you want to see what your code will do before you apply it. \n\n\nExample\n  \n\n\nterrform plan \n\n[output]\n Acquiring state lock. This may take a few moments...\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\naws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec)\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\n\nTerraform will perform the following actions:\n\n-/+ aws_instance.webserver (tainted) (new resource required)\n      id:                                \ni-00ddea272445bd4ec\n =\n \ncomputed\n (forces new resource)\n      ami:                               \nami-408c7f28\n =\n \nami-408c7f28\n\n      arn:                               \narn:aws:ec2:us-east-1:822941572458:instance/i-00ddea272445bd4ec\n =\n \ncomputed\n\n      associate_public_ip_address:       \ntrue\n =\n \ncomputed\n\n      availability_zone:                 \nus-east-1a\n =\n \ncomputed\n\n      cpu_core_count:                    \n1\n =\n \ncomputed\n\n      cpu_threads_per_core:              \n1\n =\n \ncomputed\n\n      ebs_block_device.#:                \n0\n =\n \ncomputed\n\n      ephemeral_block_device.#:          \n0\n =\n \ncomputed\n\n      get_password_data:                 \nfalse\n =\n \nfalse\n\n      instance_state:                    \nrunning\n =\n \ncomputed\n\n      instance_type:                     \nt1.micro\n =\n \nt1.micro\n\n      ipv6_address_count:                \n =\n \ncomputed\n\n      ipv6_addresses.#:                  \n0\n =\n \ncomputed\n\n      key_name:                          \nweb-admin-key\n =\n \nweb-admin-key\n\n      network_interface.#:               \n0\n =\n \ncomputed\n\n      network_interface_id:              \neni-0e92356540e1a2f47\n =\n \ncomputed\n\n      password_data:                     \n =\n \ncomputed\n\n      placement_group:                   \n =\n \ncomputed\n\n      primary_network_interface_id:      \neni-0e92356540e1a2f47\n =\n \ncomputed\n\n      private_dns:                       \nip-172-31-38-119.ec2.internal\n =\n \ncomputed\n\n      private_ip:                        \n172.31.38.119\n =\n \ncomputed\n\n      public_dns:                        \nec2-35-173-130-100.compute-1.amazonaws.com\n =\n \ncomputed\n\n      public_ip:                         \n35.173.130.100\n =\n \ncomputed\n\n      root_block_device.#:               \n1\n =\n \ncomputed\n\n      security_groups.#:                 \n1\n =\n \ncomputed\n\n      source_dest_check:                 \ntrue\n =\n \ntrue\n\n      subnet_id:                         \nsubnet-d363e58f\n =\n \ncomputed\n\n      tags.%:                            \n1\n =\n \n1\n\n      tags.Name:                         \ndemo-server\n =\n \ndemo-server\n\n      tenancy:                           \ndefault\n =\n \ncomputed\n\n      volume_tags.%:                     \n0\n =\n \ncomputed\n\n      vpc_security_group_ids.#:          \n1\n =\n \n1\n\n      vpc_security_group_ids.3215502186: \nsg-04b81bcdfa7f287b0\n =\n \nsg-04b81bcdfa7f287b0\n\n\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n\n------------------------------------------------------------------------\n\nNote: You didn't specify an \n-out\n parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if\n\nterraform apply\n is subsequently run.\n\nReleasing state lock. This may take a few moments...\n\n\n\n\n\nTerraform Apply\n\n\nTerraform apply is command which creates the resources for us. The output will look similar to \nterraform plan\n but this time you will be prompted for permisson on your console. The output is truncated from the original.\n\n\nExample\n\n\naws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\n\nTerraform will perform the following actions:\n\n-/+ aws_instance.webserver (tainted) (new resource required)\n      id:                                \ni-00ddea272445bd4ec\n =\n \ncomputed\n (forces new resource)\n      ami:                               \nami-408c7f28\n =\n \nami-408c7f28\n\n      arn:                               \narn:aws:ec2:us-east-1:822941572458:instance/\n      [...]\n      volume_tags.%:                     \n0\n =\n \ncomputed\n\n      vpc_security_group_ids.#:          \n1\n =\n \n1\n\n      vpc_security_group_ids.3215502186: \nsg-04b81bcdfa7f287b0\n =\n \nsg-04b81bcdfa7f287b0\n\n\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Destroying... (ID: i-00ddea272445bd4ec)\naws_instance.webserver: Destruction complete after 49s\n[...]\n\n\n\n\nTerraform Destroy\n\n\nThis command will delete everything that terraform manages for you. So we need to be really careful when we run this command and only run it when you know what you are doing. \n\n\nExample\n\n\nAcquiring state lock. This may take a few moments...\naws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-04264d266661e096d)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n  - aws_key_pair.webserver_key\n\n  - aws_security_group.webserver_sg\n\n\nPlan: 0 to add, 0 to change, 3 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]", 
            "title": "Important Commands"
        }, 
        {
            "location": "/02-terraform-important-commands/#important-terraform-commands", 
            "text": "", 
            "title": "Important Terraform Commands"
        }, 
        {
            "location": "/02-terraform-important-commands/#terraform-plan", 
            "text": "When you run  terraform plan  it will present you with the  execution plan . This will show you which resources are going to be created/deleted or modified. This is more like a dry run, if you want to see what your code will do before you apply it.   Example     terrform plan \n\n[output]\n Acquiring state lock. This may take a few moments...\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\naws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec)\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\n\nTerraform will perform the following actions:\n\n-/+ aws_instance.webserver (tainted) (new resource required)\n      id:                                 i-00ddea272445bd4ec  =   computed  (forces new resource)\n      ami:                                ami-408c7f28  =   ami-408c7f28 \n      arn:                                arn:aws:ec2:us-east-1:822941572458:instance/i-00ddea272445bd4ec  =   computed \n      associate_public_ip_address:        true  =   computed \n      availability_zone:                  us-east-1a  =   computed \n      cpu_core_count:                     1  =   computed \n      cpu_threads_per_core:               1  =   computed \n      ebs_block_device.#:                 0  =   computed \n      ephemeral_block_device.#:           0  =   computed \n      get_password_data:                  false  =   false \n      instance_state:                     running  =   computed \n      instance_type:                      t1.micro  =   t1.micro \n      ipv6_address_count:                  =   computed \n      ipv6_addresses.#:                   0  =   computed \n      key_name:                           web-admin-key  =   web-admin-key \n      network_interface.#:                0  =   computed \n      network_interface_id:               eni-0e92356540e1a2f47  =   computed \n      password_data:                       =   computed \n      placement_group:                     =   computed \n      primary_network_interface_id:       eni-0e92356540e1a2f47  =   computed \n      private_dns:                        ip-172-31-38-119.ec2.internal  =   computed \n      private_ip:                         172.31.38.119  =   computed \n      public_dns:                         ec2-35-173-130-100.compute-1.amazonaws.com  =   computed \n      public_ip:                          35.173.130.100  =   computed \n      root_block_device.#:                1  =   computed \n      security_groups.#:                  1  =   computed \n      source_dest_check:                  true  =   true \n      subnet_id:                          subnet-d363e58f  =   computed \n      tags.%:                             1  =   1 \n      tags.Name:                          demo-server  =   demo-server \n      tenancy:                            default  =   computed \n      volume_tags.%:                      0  =   computed \n      vpc_security_group_ids.#:           1  =   1 \n      vpc_security_group_ids.3215502186:  sg-04b81bcdfa7f287b0  =   sg-04b81bcdfa7f287b0 \n\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n\n------------------------------------------------------------------------\n\nNote: You didn't specify an  -out  parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if terraform apply  is subsequently run.\n\nReleasing state lock. This may take a few moments...", 
            "title": "Terraform Plan"
        }, 
        {
            "location": "/02-terraform-important-commands/#terraform-apply", 
            "text": "Terraform apply is command which creates the resources for us. The output will look similar to  terraform plan  but this time you will be prompted for permisson on your console. The output is truncated from the original.  Example  aws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-00ddea272445bd4ec)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n-/+ destroy and then create replacement\n\nTerraform will perform the following actions:\n\n-/+ aws_instance.webserver (tainted) (new resource required)\n      id:                                 i-00ddea272445bd4ec  =   computed  (forces new resource)\n      ami:                                ami-408c7f28  =   ami-408c7f28 \n      arn:                                arn:aws:ec2:us-east-1:822941572458:instance/\n      [...]\n      volume_tags.%:                      0  =   computed \n      vpc_security_group_ids.#:           1  =   1 \n      vpc_security_group_ids.3215502186:  sg-04b81bcdfa7f287b0  =   sg-04b81bcdfa7f287b0 \n\n\nPlan: 1 to add, 0 to change, 1 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Destroying... (ID: i-00ddea272445bd4ec)\naws_instance.webserver: Destruction complete after 49s\n[...]", 
            "title": "Terraform Apply"
        }, 
        {
            "location": "/02-terraform-important-commands/#terraform-destroy", 
            "text": "This command will delete everything that terraform manages for you. So we need to be really careful when we run this command and only run it when you know what you are doing.   Example  Acquiring state lock. This may take a few moments...\naws_security_group.webserver_sg: Refreshing state... (ID: sg-04b81bcdfa7f287b0)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-04264d266661e096d)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n  - aws_key_pair.webserver_key\n\n  - aws_security_group.webserver_sg\n\n\nPlan: 0 to add, 0 to change, 3 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]", 
            "title": "Terraform Destroy"
        }, 
        {
            "location": "/03-providers/", 
            "text": "Providers\n\n\nIn Terraform, Providers are responsible for understanding API interactions from IaaS(AWS, Azure, etc.,), PaaS(Heroku) or SaaS(CloudFlare, DNSSimple, DNSMadeEasy, etc.,). \n\n\nExample Provider\n\n\nLet's look at AWS Provider as an example.\n\n\nprovider \naws\n {\n  access_key = \n${var.aws_access_key}\n\n  secret_key = \n${var.aws_secret_key}\n\n  region     = \nus-east-1\n\n}\n\n\n\n\nAs seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In our example, we have porvided AWS access key and secret key to perform the same. \n\n\nSetting up our environment for AWS\n\n\nLet us set up our environment by creating a directory called \naws\n.\n\n\nmkdir aws\ncd aws\n\n\n\n\nAfter changing directory into \naws\n, we need to create a file named \nmain.tf\n.\n\n\ntouch main.tf\n\n\n\n\nDefine your Provider details in this main manifest. Change the region if you want to create the resources elsewhere.\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\n\n\n\nExport your AWS access and secret keys as environment variables.\n\n\nexport AWS_ACCESS_KEY_ID=\nAKIAI3NYUWMNORYTDYBC\n\nexport AWS_SECRET_ACCESS_KEY=\ntoOh/ejVKe44wx3ujr7scaehdy4\n\n\n\n\n\nFinally run the following command to initialize your environment.\n\n\nterraform init\n\n[output]\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider \naws\n (1.37.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version = \n...\n constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version = \n~\n 1.37\n\n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running \nterraform plan\n to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.\n\n\n\n\nThis should initialize the environment for our course.\n\n\nReference\n\n\nIf you want to learn more about providers, you can visit \nthis link\n.", 
            "title": "Terraform Providers"
        }, 
        {
            "location": "/03-providers/#providers", 
            "text": "In Terraform, Providers are responsible for understanding API interactions from IaaS(AWS, Azure, etc.,), PaaS(Heroku) or SaaS(CloudFlare, DNSSimple, DNSMadeEasy, etc.,).", 
            "title": "Providers"
        }, 
        {
            "location": "/03-providers/#example-provider", 
            "text": "Let's look at AWS Provider as an example.  provider  aws  {\n  access_key =  ${var.aws_access_key} \n  secret_key =  ${var.aws_secret_key} \n  region     =  us-east-1 \n}  As seen in the above given example, Provider is a way to instruct Terraform to interact with AWS API. Every provider needs some kind of credentials to get authenticated with the API. In our example, we have porvided AWS access key and secret key to perform the same.", 
            "title": "Example Provider"
        }, 
        {
            "location": "/03-providers/#setting-up-our-environment-for-aws", 
            "text": "Let us set up our environment by creating a directory called  aws .  mkdir aws\ncd aws  After changing directory into  aws , we need to create a file named  main.tf .  touch main.tf  Define your Provider details in this main manifest. Change the region if you want to create the resources elsewhere.  provider  aws  {\n  region =  us-east-1 \n}  Export your AWS access and secret keys as environment variables.  export AWS_ACCESS_KEY_ID= AKIAI3NYUWMNORYTDYBC \nexport AWS_SECRET_ACCESS_KEY= toOh/ejVKe44wx3ujr7scaehdy4   Finally run the following command to initialize your environment.  terraform init\n\n[output]\nInitializing provider plugins...\n- Checking for available provider plugins on https://releases.hashicorp.com...\n- Downloading plugin for provider  aws  (1.37.0)...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version =  ...  constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version =  ~  1.37 \n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running  terraform plan  to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.  This should initialize the environment for our course.", 
            "title": "Setting up our environment for AWS"
        }, 
        {
            "location": "/03-providers/#reference", 
            "text": "If you want to learn more about providers, you can visit  this link .", 
            "title": "Reference"
        }, 
        {
            "location": "/04-resources-part1/", 
            "text": "Resources\n\n\nResources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. To do so, you will have to define them in a terraform manifest and apply them. \n\n\nCreating our first Resource\n\n\nLet us create an EC2 instance, which is going to be our first resource on AWS using Terraform. \n\n\nEvery resorce has the following syntax.\n\n\nresource syntax\n\n\nresource \nresource_type\n \nresource_name\n {\n  config1 = value1\n  config2 = value2\n}\n\n\n\n\nHere, \n  resource_type = The type of the resouce that we create/delete/modfiy\n  resource_name = Give the resource a name for Terraform internal references.\n  config(1-n)   = The properties of the reosurce your manipulating.\n\n\nIn your main.tf, add this block next to your Provider definition. \n\n\nan ec2 resource\n\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n}\n\n\n\n\nHere, to compare it with the syntax,\n  resource_type = aws_instance\n  resource_name = webserver\n  config1       = ami\n  value1        = ami-408c7f28(ubuntu-14.04)\n  config2       = instance_type\n  value2        = t1.micro\n\n\nYour \nmain.tf\n file should look like the following. \n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n}\n\n\n\n\nTerraform Plan\n\n\nThen run \nterraform plan\n to see what will happen if we apply the manifest.\n\n\nterraform plan\n\n[output]\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\nTerraform will perform the following actions:\n\n  + aws_instance.webserver\n      id:                           \ncomputed\n\n      ami:                          \nami-408c7f28\n\n      arn:                          \ncomputed\n\n      associate_public_ip_address:  \ncomputed\n\n      availability_zone:            \ncomputed\n\n      cpu_core_count:               \ncomputed\n\n      cpu_threads_per_core:         \ncomputed\n\n      ebs_block_device.#:           \ncomputed\n\n      ephemeral_block_device.#:     \ncomputed\n\n      get_password_data:            \nfalse\n\n      instance_state:               \ncomputed\n\n      instance_type:                \nt1.micro\n\n[...]\n\nPlan: 1 to add, 0 to change, 0 to destroy.\n\n------------------------------------------------------------------------\n\nNote: You didn't specify an \n-out\n parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if\n\nterraform apply\n is subsequently run.\n\n\n\n\nTerraform Apply\n\n\nThen run, \nterraform apply\n to actually create the resource on AWS.\n\n\nterraform apply\n\n[output]\n[...]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Creation complete after 49s (ID: i-02489cdf638f05bbd)\n\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.\n\n\n\n\nWe have successfully created our first reosource on AWS. Please check your AWS console to check the properties(AMI and instance type) of the machine.\n\n\n\n\nReference\n\n\nIf you need further details about resources, please visit this \nlink", 
            "title": "Terraform Building Blocks - Part 1"
        }, 
        {
            "location": "/04-resources-part1/#resources", 
            "text": "Resources are the building block in Terraform. These the actual cloud entities that you are either creating/deleting or modifying. To do so, you will have to define them in a terraform manifest and apply them.", 
            "title": "Resources"
        }, 
        {
            "location": "/04-resources-part1/#creating-our-first-resource", 
            "text": "Let us create an EC2 instance, which is going to be our first resource on AWS using Terraform.   Every resorce has the following syntax.  resource syntax  resource  resource_type   resource_name  {\n  config1 = value1\n  config2 = value2\n}  Here, \n  resource_type = The type of the resouce that we create/delete/modfiy\n  resource_name = Give the resource a name for Terraform internal references.\n  config(1-n)   = The properties of the reosurce your manipulating.  In your main.tf, add this block next to your Provider definition.   an ec2 resource  resource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n}  Here, to compare it with the syntax,\n  resource_type = aws_instance\n  resource_name = webserver\n  config1       = ami\n  value1        = ami-408c7f28(ubuntu-14.04)\n  config2       = instance_type\n  value2        = t1.micro  Your  main.tf  file should look like the following.   provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n}", 
            "title": "Creating our first Resource"
        }, 
        {
            "location": "/04-resources-part1/#terraform-plan", 
            "text": "Then run  terraform plan  to see what will happen if we apply the manifest.  terraform plan\n\n[output]\nRefreshing Terraform state in-memory prior to plan...\nThe refreshed state will be used to calculate this plan, but will not be\npersisted to local or remote state storage.\n\n\n------------------------------------------------------------------------\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  + create\n\nTerraform will perform the following actions:\n\n  + aws_instance.webserver\n      id:                            computed \n      ami:                           ami-408c7f28 \n      arn:                           computed \n      associate_public_ip_address:   computed \n      availability_zone:             computed \n      cpu_core_count:                computed \n      cpu_threads_per_core:          computed \n      ebs_block_device.#:            computed \n      ephemeral_block_device.#:      computed \n      get_password_data:             false \n      instance_state:                computed \n      instance_type:                 t1.micro \n[...]\n\nPlan: 1 to add, 0 to change, 0 to destroy.\n\n------------------------------------------------------------------------\n\nNote: You didn't specify an  -out  parameter to save this plan, so Terraform\ncan't guarantee that exactly these actions will be performed if terraform apply  is subsequently run.", 
            "title": "Terraform Plan"
        }, 
        {
            "location": "/04-resources-part1/#terraform-apply", 
            "text": "Then run,  terraform apply  to actually create the resource on AWS.  terraform apply\n\n[output]\n[...]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Creation complete after 49s (ID: i-02489cdf638f05bbd)\n\nApply complete! Resources: 1 added, 0 changed, 0 destroyed.  We have successfully created our first reosource on AWS. Please check your AWS console to check the properties(AMI and instance type) of the machine.", 
            "title": "Terraform Apply"
        }, 
        {
            "location": "/04-resources-part1/#reference", 
            "text": "If you need further details about resources, please visit this  link", 
            "title": "Reference"
        }, 
        {
            "location": "/05-resources-part2/", 
            "text": "Resources - Part 2\n\n\nThe ec2 instance that we have created is not that useful when we don't have access to it. So let us delete it and  we shall set up this again with additional resources. \n\n\nLet us create a security group, which allows us to ssh(port 22) into the machine.\n\n\nfile: main.tf\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n}\n\nresource \naws_security_group\n \nwebserver_sg\n {\n\n    name = \nwebserver-sg\n\n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    = \ntcp\n\n        cidr_blocks = [\n0.0.0.0/0\n]\n    }\n}\n\n\n\n\nHere,\n  Resource type = aws_security_group,\n  Resource name = webserver_sg\n\n\nThis \naws_security_group\n resource allows us to ssh into the instance.\n\n\nWe need to create the EC2 instance with this security group. To do that, \n\n\nThe final requirement is a \nkey pair\n using which we can login to the machine. Let us use \naws_key_pair\n to register the key with AWS and then use in our ec2 instance.\n\n\nTo do this, you will need to create a key pair in your local machine. Run the following commands. This will create one public key and a private key.\n\n\nroot@vibe$ ssh-keygen -t rsa\n\n[output]\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/vibe/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/vibe/.ssh/id_rsa.\nYour public key has been saved in /home/vibe/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:nSnSLKDvnLv22LFX+wKYMa0TvSt3AL406z+Asj/GSak vibe@vibes-MacBook-Air.local\nThe key's randomart image is:\n+---[RSA 2048]----+\n|                 |\n|                 |\n|    .  o         |\n|   . .=oo. o     |\n|  .  +oOS.+      |\n|  ..+ Xo+..      |\n|   *.o.* = .     |\n|  Eo*++o= +      |\n|   +O*==.o o.    |\n+----[SHA256]-----+\n\n\n\n\nCopy the content of your public key\n\n\ncat ~/.ssh/id_rsa.pub\n\n[output]\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n\n\n\nPaste the content of public key in the public_key\n\n\nfile: main.tf\n\n\n[...]\n\nresource \naws_security_group\n \nwebserver_sg\n {\n\n    name = \nwebserver-sg\n\n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    = \ntcp\n\n        cidr_blocks = [\n0.0.0.0/0\n]\n    }\n}\n\nresource \naws_key_pair\n \nwebserver_key\n {\n  key_name   = \nweb-admin-key\n\n  public_key = \nssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n}\n\n\n\n\nWe need to make sure our instance uses this key. To do that, we should add one more attribute to our \naws_instance\n module. We will also tag the instace with a name.\n\n\nfile: main.tf\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n  key_name      = \nweb-admin-key\n\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n\n[...]\n\n\n\n\nThe final file shoudl look like the following.\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n  key_name      = \nweb-admin-key\n\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n\nresource \naws_security_group\n \nwebserver_sg\n {\n\n        name = \nwebserver-sg\n\n\n        ingress {\n                from_port   = 22\n                to_port     = 22\n                protocol    = \ntcp\n\n                cidr_blocks = [\n0.0.0.0/0\n]\n        }\n}\n\nresource \naws_key_pair\n \nwebserver_key\n {\n  key_name   = \nweb-admin-key\n\n  public_key = \nssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n}\n\n\n\n\nExplicit Dependency\n\n\nWhen we apply the manifest, we will get the following error.\n\n\nterraform apply\n\n[output]\naws_security_group.webserver_sg: Still creating... (10s elapsed)\naws_security_group.webserver_sg: Creation complete after 11s (ID: sg-0c22a3497351d1caa)\n\nError: Error applying plan:\n\n2 error(s) occurred:\n\n* aws_instance.webserver: 1 error(s) occurred:\n\n* aws_instance.webserver: Error launching source instance: InvalidKeyPair.NotFound: The key pair 'web-admin-key' does not exist\n    status code: 400, request id: 36af6c0c-9016-4dc4-bd3a-7b94fc3dfade\n* aws_key_pair.webserver_key: 1 error(s) occurred:\n\n* aws_key_pair.webserver_key: Error import KeyPair: InvalidKey.Format: Key is not in valid OpenSSH public key format\n    status code: 400, request id: 8a3697d2-4450-4150-86e0-3b75c0d43b80\n\nTerraform does not automatically rollback in the face of errors.\nInstead, your Terraform state file has been partially updated with\nany resources that successfully completed. Please address the error\nabove and apply again to incrementally change your infrastructure.\n\n\n\n\nThis is because, the ec2 resource tries to use the key even before it is created. We can control the order of execution in two ways.\n  1. Implicit Dependecy (Automatic Dependency)\n\n  2. Explicit Dependency (Manual Dependency)  \n\n\nWe will learn more about \nImplicit Dependency\n in the next chapter. Now we will focus on adding \nExplicit Dependency\n to \naws_instance\n resource to depend on \naws_key_pair\n resource.\n\n\nThis will guarantee the creation of key pair before the instance get's created. In your instance block add the following,\n\n\nfile: main.tf\n\n\n[...]\nresource \naws_instance\n \nwebserver\n {\n  ami           = \nami-408c7f28\n\n  instance_type = \nt1.micro\n\n  key_name      = \nweb-admin-key\n\n\n  depends_on = [\naws_key_pair.webserver_key\n]\n  tags {\n    Name = \nweberserver\n\n  }\n}\n[...]\n\n\n\n\nSyntax: \ndepends_on = [\"resource_type.resource_name\"]\n\n\nIdempotency\n\n\nFinally apply the manifest by running,\n\n\nterraform apply\n\n[output]\nPlan: 2 to add, 0 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_key_pair.webserver_key: Creating...\n  fingerprint: \n =\n \ncomputed\n\n  key_name:    \n =\n \nweb-admin-key\n\n  public_key:  \n =\n \nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\naws_key_pair.webserver_key: Creation complete after 3s (ID: web-admin-key)\naws_instance.webserver: Creating...\n  ami:                          \n =\n \nami-408c7f28\n\n  arn:                          \n =\n \ncomputed\n\n  associate_public_ip_address:  \n =\n \ncomputed\n\n  availability_zone:            \n =\n \ncomputed\n\n  cpu_core_count:               \n =\n \ncomputed\n\n  cpu_threads_per_core:         \n =\n \ncomputed\n\n  ebs_block_device.#:           \n =\n \ncomputed\n\n  ephemeral_block_device.#:     \n =\n \ncomputed\n\n  get_password_data:            \n =\n \nfalse\n\n  instance_state:               \n =\n \ncomputed\n\n  instance_type:                \n =\n \nt1.micro\n\n  ipv6_address_count:           \n =\n \ncomputed\n\n  ipv6_addresses.#:             \n =\n \ncomputed\n\n  key_name:                     \n =\n \nweb-admin-key\n\n  network_interface.#:          \n =\n \ncomputed\n\n  network_interface_id:         \n =\n \ncomputed\n\n  password_data:                \n =\n \ncomputed\n\n  placement_group:              \n =\n \ncomputed\n\n  primary_network_interface_id: \n =\n \ncomputed\n\n  private_dns:                  \n =\n \ncomputed\n\n  private_ip:                   \n =\n \ncomputed\n\n  public_dns:                   \n =\n \ncomputed\n\n  public_ip:                    \n =\n \ncomputed\n\n  root_block_device.#:          \n =\n \ncomputed\n\n  security_groups.#:            \n =\n \ncomputed\n\n  source_dest_check:            \n =\n \ntrue\n\n  subnet_id:                    \n =\n \ncomputed\n\n  tags.%:                       \n =\n \n1\n\n  tags.Name:                    \n =\n \nweberserver\n\n  tenancy:                      \n =\n \ncomputed\n\n  volume_tags.%:                \n =\n \ncomputed\n\n  vpc_security_group_ids.#:     \n =\n \ncomputed\n\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Creation complete after 37s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 2 added, 0 changed, 0 destroyed.\n\n\n\n\nIf you have noticed, Terraform did not create the security group this time around. The reason for this behaviour is, it had created the security group resource in the first run itself. So it did not create the same resource again when we applied the second time. This behaviour is called \nIdempotency\n.\n\n\nReference\n\n\nIf you want to know more about, resource dependencies then please refer \nthis link\n.", 
            "title": "Terraform Building Blocks - Part 2"
        }, 
        {
            "location": "/05-resources-part2/#resources-part-2", 
            "text": "The ec2 instance that we have created is not that useful when we don't have access to it. So let us delete it and  we shall set up this again with additional resources.   Let us create a security group, which allows us to ssh(port 22) into the machine.  file: main.tf  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n}\n\nresource  aws_security_group   webserver_sg  {\n\n    name =  webserver-sg \n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    =  tcp \n        cidr_blocks = [ 0.0.0.0/0 ]\n    }\n}  Here,\n  Resource type = aws_security_group,\n  Resource name = webserver_sg  This  aws_security_group  resource allows us to ssh into the instance.  We need to create the EC2 instance with this security group. To do that,   The final requirement is a  key pair  using which we can login to the machine. Let us use  aws_key_pair  to register the key with AWS and then use in our ec2 instance.  To do this, you will need to create a key pair in your local machine. Run the following commands. This will create one public key and a private key.  root@vibe$ ssh-keygen -t rsa\n\n[output]\nGenerating public/private rsa key pair.\nEnter file in which to save the key (/home/vibe/.ssh/id_rsa):\nEnter passphrase (empty for no passphrase):\nEnter same passphrase again:\nYour identification has been saved in /home/vibe/.ssh/id_rsa.\nYour public key has been saved in /home/vibe/.ssh/id_rsa.pub.\nThe key fingerprint is:\nSHA256:nSnSLKDvnLv22LFX+wKYMa0TvSt3AL406z+Asj/GSak vibe@vibes-MacBook-Air.local\nThe key's randomart image is:\n+---[RSA 2048]----+\n|                 |\n|                 |\n|    .  o         |\n|   . .=oo. o     |\n|  .  +oOS.+      |\n|  ..+ Xo+..      |\n|   *.o.* = .     |\n|  Eo*++o= +      |\n|   +O*==.o o.    |\n+----[SHA256]-----+  Copy the content of your public key  cat ~/.ssh/id_rsa.pub\n\n[output]\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local  Paste the content of public key in the public_key  file: main.tf  [...]\n\nresource  aws_security_group   webserver_sg  {\n\n    name =  webserver-sg \n\n    ingress {\n        from_port   = 22\n        to_port     = 22\n        protocol    =  tcp \n        cidr_blocks = [ 0.0.0.0/0 ]\n    }\n}\n\nresource  aws_key_pair   webserver_key  {\n  key_name   =  web-admin-key \n  public_key =  ssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n}  We need to make sure our instance uses this key. To do that, we should add one more attribute to our  aws_instance  module. We will also tag the instace with a name.  file: main.tf  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n  key_name      =  web-admin-key \n\n  tags {\n    Name =  weberserver \n  }\n}\n\n[...]  The final file shoudl look like the following.  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n  key_name      =  web-admin-key \n\n  tags {\n    Name =  weberserver \n  }\n}\n\nresource  aws_security_group   webserver_sg  {\n\n        name =  webserver-sg \n\n        ingress {\n                from_port   = 22\n                to_port     = 22\n                protocol    =  tcp \n                cidr_blocks = [ 0.0.0.0/0 ]\n        }\n}\n\nresource  aws_key_pair   webserver_key  {\n  key_name   =  web-admin-key \n  public_key =  ssh-rsa sh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \n}", 
            "title": "Resources - Part 2"
        }, 
        {
            "location": "/05-resources-part2/#explicit-dependency", 
            "text": "When we apply the manifest, we will get the following error.  terraform apply\n\n[output]\naws_security_group.webserver_sg: Still creating... (10s elapsed)\naws_security_group.webserver_sg: Creation complete after 11s (ID: sg-0c22a3497351d1caa)\n\nError: Error applying plan:\n\n2 error(s) occurred:\n\n* aws_instance.webserver: 1 error(s) occurred:\n\n* aws_instance.webserver: Error launching source instance: InvalidKeyPair.NotFound: The key pair 'web-admin-key' does not exist\n    status code: 400, request id: 36af6c0c-9016-4dc4-bd3a-7b94fc3dfade\n* aws_key_pair.webserver_key: 1 error(s) occurred:\n\n* aws_key_pair.webserver_key: Error import KeyPair: InvalidKey.Format: Key is not in valid OpenSSH public key format\n    status code: 400, request id: 8a3697d2-4450-4150-86e0-3b75c0d43b80\n\nTerraform does not automatically rollback in the face of errors.\nInstead, your Terraform state file has been partially updated with\nany resources that successfully completed. Please address the error\nabove and apply again to incrementally change your infrastructure.  This is because, the ec2 resource tries to use the key even before it is created. We can control the order of execution in two ways.\n  1. Implicit Dependecy (Automatic Dependency) \n  2. Explicit Dependency (Manual Dependency)    We will learn more about  Implicit Dependency  in the next chapter. Now we will focus on adding  Explicit Dependency  to  aws_instance  resource to depend on  aws_key_pair  resource.  This will guarantee the creation of key pair before the instance get's created. In your instance block add the following,  file: main.tf  [...]\nresource  aws_instance   webserver  {\n  ami           =  ami-408c7f28 \n  instance_type =  t1.micro \n  key_name      =  web-admin-key \n\n  depends_on = [ aws_key_pair.webserver_key ]\n  tags {\n    Name =  weberserver \n  }\n}\n[...]  Syntax:  depends_on = [\"resource_type.resource_name\"]", 
            "title": "Explicit Dependency"
        }, 
        {
            "location": "/05-resources-part2/#idempotency", 
            "text": "Finally apply the manifest by running,  terraform apply\n\n[output]\nPlan: 2 to add, 0 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_key_pair.webserver_key: Creating...\n  fingerprint:   =   computed \n  key_name:      =   web-admin-key \n  public_key:    =   ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \naws_key_pair.webserver_key: Creation complete after 3s (ID: web-admin-key)\naws_instance.webserver: Creating...\n  ami:                            =   ami-408c7f28 \n  arn:                            =   computed \n  associate_public_ip_address:    =   computed \n  availability_zone:              =   computed \n  cpu_core_count:                 =   computed \n  cpu_threads_per_core:           =   computed \n  ebs_block_device.#:             =   computed \n  ephemeral_block_device.#:       =   computed \n  get_password_data:              =   false \n  instance_state:                 =   computed \n  instance_type:                  =   t1.micro \n  ipv6_address_count:             =   computed \n  ipv6_addresses.#:               =   computed \n  key_name:                       =   web-admin-key \n  network_interface.#:            =   computed \n  network_interface_id:           =   computed \n  password_data:                  =   computed \n  placement_group:                =   computed \n  primary_network_interface_id:   =   computed \n  private_dns:                    =   computed \n  private_ip:                     =   computed \n  public_dns:                     =   computed \n  public_ip:                      =   computed \n  root_block_device.#:            =   computed \n  security_groups.#:              =   computed \n  source_dest_check:              =   true \n  subnet_id:                      =   computed \n  tags.%:                         =   1 \n  tags.Name:                      =   weberserver \n  tenancy:                        =   computed \n  volume_tags.%:                  =   computed \n  vpc_security_group_ids.#:       =   computed \naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Creation complete after 37s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 2 added, 0 changed, 0 destroyed.  If you have noticed, Terraform did not create the security group this time around. The reason for this behaviour is, it had created the security group resource in the first run itself. So it did not create the same resource again when we applied the second time. This behaviour is called  Idempotency .", 
            "title": "Idempotency"
        }, 
        {
            "location": "/05-resources-part2/#reference", 
            "text": "If you want to know more about, resource dependencies then please refer  this link .", 
            "title": "Reference"
        }, 
        {
            "location": "/06-variables-and-outputs/", 
            "text": "Variables\n\n\nLet us try to ssh into the machine that we've just created. Get the public IP from the AWS console.\n\n\nssh ubuntu@34.203.194.201\n\n[output]\nssh: connect to host 34.203.194.201 port 22: Operation timed out\n\n\n\n\nYou will not be able to SSH. The reason is we have not associated the security group that we have created with this instance. The instance is still using the default security group which doesn't allow ssh. \n\n\n\n\nWe need to fix this issue. Let us associate our security group with this machine.\n\n\nfile: main.tf\n\n\nBad Practice\n\n\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \nami-408c7f28\n\n  instance_type          = \nt1.micro\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = \nsg-0c22a3497351d1caa\n\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n\n\n\n\nWe can manually copy the ID of the security group and apply the manifest. This would work but this is an ugly fix. We should let Terraform to find the these kind of mutable data. Thats where \nVariables\n come into picture.\n\n\nType 1: Attribute of a Resource\n\n\nfile: main.tf\n\n\nGood Practice\n\n\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \nami-408c7f28\n\n  instance_type          = \nt1.micro\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.webserver_sg.id}\n]\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n\n\n\n\nThis is how variable interpolation works in Terraform. \n\n\nSyntax: ${TYPE.NAME.ATTRIBUTE}\n\n\nIn our case, it is, \n${aws_security_group.webserver_sg.id}\n.\nHere,\n  aws_security_group =\n TYPE\n  webserver_sg       =\n NAME\n  id                 =\n ATTRIBUTE\n\n\nEvery resource has set of attribute that can be referred as a variable. \naws_security_group\n resource has the following attributes which can be referred.\n\n  * id - The ID of the security group\n\n  * arn - The ARN of the security group\n\n  * vpc_id - The VPC ID.\n\n  * owner_id - The owner ID.\n\n  * name - The name of the security group\n\n  * description - The description of the security group\n\n  * ingress - The ingress rules. See above for more.\n\n  * egress - The egress rules. See above for more.  \n\n\nThis also creates an \nImplicit Dependency\n. Terraform will know that this security group has to be created before the EC2 instance since the later refers to it. Let us apply the given manifest.  \n\n\nLet us apply the manifest.\n\n\nterraform apply \n\n[output]\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      vpc_security_group_ids.118229083:  \n =\n \nsg-0c22a3497351d1caa\n\n      vpc_security_group_ids.3314100969: \nsg-a42b7ae9\n =\n \n\n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  vpc_security_group_ids.118229083:  \n =\n \nsg-0c22a3497351d1caa\n\n  vpc_security_group_ids.3314100969: \nsg-a42b7ae9\n =\n \n\naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 13s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.\n\n\n\n\nCheck in your AWS console to check the same.\n\n\n\n\nNow you should be able to SSH into the machine.\n\n\nssh ubuntu@34.203.194.201\n\n[output]\nWarning: Permanently added '34.203.194.201' (ECDSA) to the list of known hosts.\nWelcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-29-generic x86_64)\n\nubuntu@ip-172-31-40-32:~$\n\n\n\n\nExercise: Remove the explicit dependecy by using the key_pair with above given attribute reference method\n \n\n\nType 2: User Defined(Input) Variables\n\n\nIt is always a good practice to remove data from code. In our manifest, we are hardcoding all the values. Instead we should use variables to define the values and reference them in the manifest. \n\n\nCreate a new file with the name \nvariables.tf\n\n\ntouch variables.tf\n\n\n\n\nSyntax\n:\n\n\nvariable \nname\n {\n  description = \ndescribe your variable\n\n  default     = \ndefault value\n\n}\n\n\n\n\nLet us define our first variable in this file.\n\n\nfile: variables.tf\n\n\nvariable \nami\n {\n  description = \nami for the instance\n\n  default     = \nami-408c7f28\n\n}\n\n\n\n\nThis variable can be referenced in the main manifest like the following.\n\n\n[...]\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \n${var.ami}\n\n  instance_type          = \nt1.micro\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.webserver_sg.id}\n]\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \nweberserver\n\n  }\n}\n[...]\n\n\n\n\nLet us apply the manifest to see if this works. Terraform automatically loads all the files with \n.tf\n extension from the working directory. So we do not need to implicitly mention about the variable file.\n\n\nterraform apply\n\n[output]\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n\n\n\n\nLet us parameterize some properties from our main manifest.\n\n\nfile: variables.tf\n\n\n# default type is string\nvariable \nami\n {\n  description = \nami for the instance\n\n  default     = \nami-408c7f28\n\n}\n\n# map type variable definition\nvariable \ninstance\n {\n  description = \ninstance parameters\n\n  type        = map\n  default     = {\n    \ntype\n = \nt1.micro\n\n    \nname\n = \ndevops-server\n\n  }\n}\n\nvariable \nkey_name\n {\n  description = \nname of the key\n\n  default     = \nweb-admin-key\n\n}\n\nvariable \nkey_pub\n {\n  description = \ncontent of public key\n\n  default     = \nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local\n\n}\n\n\n\n\nHere is fully parameterized main manifest.\n\nfile: main.tf\n\n\nprovider \naws\n {\n  region = \nus-east-1\n\n}\n\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \n${var.ami}\n\n  instance_type          = \n${var.instance[\ntype\n]}\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.webserver_sg.id}\n]\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \n${var.instance[\nname\n]}\n\n  }\n}\n\nresource \naws_security_group\n \nwebserver_sg\n {\n  name = \nwebserver-sg\n\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \ntcp\n\n    cidr_blocks = [\n0.0.0.0/0\n]\n  }\n}\n\nresource \naws_key_pair\n \nwebserver_key\n {\n  key_name   = \n${var.key_name}\n\n  public_key = \n${var.key_pub}\n\n}\n\n\n\n\nI've intentionally set the variable \ninstance.name\n to \ndemo-server\n. Let us apply the manifest.\n\n\nterraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      tags.Name: \nweberserver\n =\n \ndevops-server\n\n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  tags.Name: \nweberserver\n =\n \ndevops-server\n\naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 14s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.\n\n\n\n\nTerraform has substituted the value of \ninstance name\n from variables, thus it has changed the resource as well.\n\n\nType 3: Output Variables\n\n\nOutput variables help us to refer the metadata of resources after they are applied. This saves a lot of time, because we don't have to find go to AWS web console to find the details.\n\n\nLet us get the public ip of the instance we've created by using output variable.\n\n\nfile: main.tf\n\n\n[...]\noutput \nwebserver_ip\n {\n    value = \n${aws_instance.webserver.public_ip}\n\n}\n[...]\n\n\n\n\nOutput variables also uses variable interpolation. \n\n\nRun \nterraform apply\n to see output variables in action.\n\n\nterraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 34.203.194.201\n\n\n\n\nReference\n\n\nIf you want know more about variables, please visit the \nofficial documentation\n.", 
            "title": "Input and Output Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#variables", 
            "text": "Let us try to ssh into the machine that we've just created. Get the public IP from the AWS console.  ssh ubuntu@34.203.194.201\n\n[output]\nssh: connect to host 34.203.194.201 port 22: Operation timed out  You will not be able to SSH. The reason is we have not associated the security group that we have created with this instance. The instance is still using the default security group which doesn't allow ssh.    We need to fix this issue. Let us associate our security group with this machine.  file: main.tf  Bad Practice  resource  aws_instance   webserver  {\n  ami                    =  ami-408c7f28 \n  instance_type          =  t1.micro \n  key_name               =  web-admin-key \n  vpc_security_group_ids =  sg-0c22a3497351d1caa \n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  weberserver \n  }\n}  We can manually copy the ID of the security group and apply the manifest. This would work but this is an ugly fix. We should let Terraform to find the these kind of mutable data. Thats where  Variables  come into picture.", 
            "title": "Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#type-1-attribute-of-a-resource", 
            "text": "file: main.tf  Good Practice  resource  aws_instance   webserver  {\n  ami                    =  ami-408c7f28 \n  instance_type          =  t1.micro \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.webserver_sg.id} ]\n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  weberserver \n  }\n}  This is how variable interpolation works in Terraform.   Syntax: ${TYPE.NAME.ATTRIBUTE}  In our case, it is,  ${aws_security_group.webserver_sg.id} .\nHere,\n  aws_security_group =  TYPE\n  webserver_sg       =  NAME\n  id                 =  ATTRIBUTE  Every resource has set of attribute that can be referred as a variable.  aws_security_group  resource has the following attributes which can be referred. \n  * id - The ID of the security group \n  * arn - The ARN of the security group \n  * vpc_id - The VPC ID. \n  * owner_id - The owner ID. \n  * name - The name of the security group \n  * description - The description of the security group \n  * ingress - The ingress rules. See above for more. \n  * egress - The egress rules. See above for more.    This also creates an  Implicit Dependency . Terraform will know that this security group has to be created before the EC2 instance since the later refers to it. Let us apply the given manifest.    Let us apply the manifest.  terraform apply \n\n[output]\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      vpc_security_group_ids.118229083:    =   sg-0c22a3497351d1caa \n      vpc_security_group_ids.3314100969:  sg-a42b7ae9  =   \n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  vpc_security_group_ids.118229083:    =   sg-0c22a3497351d1caa \n  vpc_security_group_ids.3314100969:  sg-a42b7ae9  =   \naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 13s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.  Check in your AWS console to check the same.   Now you should be able to SSH into the machine.  ssh ubuntu@34.203.194.201\n\n[output]\nWarning: Permanently added '34.203.194.201' (ECDSA) to the list of known hosts.\nWelcome to Ubuntu 14.04 LTS (GNU/Linux 3.13.0-29-generic x86_64)\n\nubuntu@ip-172-31-40-32:~$  Exercise: Remove the explicit dependecy by using the key_pair with above given attribute reference method", 
            "title": "Type 1: Attribute of a Resource"
        }, 
        {
            "location": "/06-variables-and-outputs/#type-2-user-definedinput-variables", 
            "text": "It is always a good practice to remove data from code. In our manifest, we are hardcoding all the values. Instead we should use variables to define the values and reference them in the manifest.   Create a new file with the name  variables.tf  touch variables.tf  Syntax :  variable  name  {\n  description =  describe your variable \n  default     =  default value \n}  Let us define our first variable in this file.  file: variables.tf  variable  ami  {\n  description =  ami for the instance \n  default     =  ami-408c7f28 \n}  This variable can be referenced in the main manifest like the following.  [...]\nresource  aws_instance   webserver  {\n  ami                    =  ${var.ami} \n  instance_type          =  t1.micro \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.webserver_sg.id} ]\n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  weberserver \n  }\n}\n[...]  Let us apply the manifest to see if this works. Terraform automatically loads all the files with  .tf  extension from the working directory. So we do not need to implicitly mention about the variable file.  terraform apply\n\n[output]\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.  Let us parameterize some properties from our main manifest.  file: variables.tf  # default type is string\nvariable  ami  {\n  description =  ami for the instance \n  default     =  ami-408c7f28 \n}\n\n# map type variable definition\nvariable  instance  {\n  description =  instance parameters \n  type        = map\n  default     = {\n     type  =  t1.micro \n     name  =  devops-server \n  }\n}\n\nvariable  key_name  {\n  description =  name of the key \n  default     =  web-admin-key \n}\n\nvariable  key_pub  {\n  description =  content of public key \n  default     =  ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQC4Q2TBuAD7ijkPjp+/Hl/QnrNo4hoZEz/l+UBsfvlDuJk8zfh0ivnQLtoYyXNuJ3/BjTVVIchrGo8CLZdTco//n+YBvMqgW4Wg5F92JNNkR5L5x04ELRUmC3ed1ZqbwrLmujzB33nMJ8Ld5dJjtS55KJa5MwkCaP7lqGicU2NgXe+if2DhCKW/lZyCpkkvRgmB7oEqj6aBWNjp+FMY4v6BtcmmB/+1Ry+GMvmZJO1EjSeUHAWCec3snX7TxJKHf4opwTHxknmhRKkz8+pS8rxyjiBeyncxP9jL9Tx/Zh6qmExCUfuhAWk87sjbb3j0enVs2LtzJOG9eBZ726wD83TJ vibe@vibes-MacBook-Air.local \n}  Here is fully parameterized main manifest. file: main.tf  provider  aws  {\n  region =  us-east-1 \n}\n\nresource  aws_instance   webserver  {\n  ami                    =  ${var.ami} \n  instance_type          =  ${var.instance[ type ]} \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.webserver_sg.id} ]\n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  ${var.instance[ name ]} \n  }\n}\n\nresource  aws_security_group   webserver_sg  {\n  name =  webserver-sg \n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    =  tcp \n    cidr_blocks = [ 0.0.0.0/0 ]\n  }\n}\n\nresource  aws_key_pair   webserver_key  {\n  key_name   =  ${var.key_name} \n  public_key =  ${var.key_pub} \n}  I've intentionally set the variable  instance.name  to  demo-server . Let us apply the manifest.  terraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  ~ update in-place\n\nTerraform will perform the following actions:\n\n  ~ aws_instance.webserver\n      tags.Name:  weberserver  =   devops-server \n\n\nPlan: 0 to add, 1 to change, 0 to destroy.\n\nDo you want to perform these actions?\n  Terraform will perform the actions described above.\n  Only 'yes' will be accepted to approve.\n\n  Enter a value: yes\n\naws_instance.webserver: Modifying... (ID: i-0a7d259b3126e16b8)\n  tags.Name:  weberserver  =   devops-server \naws_instance.webserver: Still modifying... (ID: i-0a7d259b3126e16b8, 10s elapsed)\naws_instance.webserver: Modifications complete after 14s (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 1 changed, 0 destroyed.  Terraform has substituted the value of  instance name  from variables, thus it has changed the resource as well.", 
            "title": "Type 2: User Defined(Input) Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#type-3-output-variables", 
            "text": "Output variables help us to refer the metadata of resources after they are applied. This saves a lot of time, because we don't have to find go to AWS web console to find the details.  Let us get the public ip of the instance we've created by using output variable.  file: main.tf  [...]\noutput  webserver_ip  {\n    value =  ${aws_instance.webserver.public_ip} \n}\n[...]  Output variables also uses variable interpolation.   Run  terraform apply  to see output variables in action.  terraform apply\n\n[output]\naws_security_group.webserver_sg: Refreshing state... (ID: sg-0c22a3497351d1caa)\naws_key_pair.webserver_key: Refreshing state... (ID: web-admin-key)\naws_instance.webserver: Refreshing state... (ID: i-0a7d259b3126e16b8)\n\nApply complete! Resources: 0 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 34.203.194.201", 
            "title": "Type 3: Output Variables"
        }, 
        {
            "location": "/06-variables-and-outputs/#reference", 
            "text": "If you want know more about variables, please visit the  official documentation .", 
            "title": "Reference"
        }, 
        {
            "location": "/07-provisioners/", 
            "text": "Provisioners\n\n\nProvisioners are used to execute scripts either on local machines or on remote machines. \nProvisioners will run at either\n  1. Resource creation time , hence called \nCreation-Time provisioner\n or\n\n  2. Resource destruction time, hence called \nDestroy-Time provisioner\n  \n\n\nMost generally used provisioners are,\n\n  * file        =\n copy file from local to remote\n  * local-exec  =\n execute on the machine where you run Terraform commands\n  * remote-exec =\n execute on the machine created/modified by Terrform\n\n\nDevops Demo Application\n\n\nWe will set up \nthis application\n using creation-time provisioner. \n\n\nFile Provisioner\n\n\nCreate a new file with the name \nuser-data.sh\n\n\ntouch user-data.sh\n\n\n\n\nfile: user-data.sh\n\n\n#!/bin/bash\nsudo apt update\nsudo apt install -y software-properties-common language-pack-en-base dialog apt-utils\nsudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nsudo cp /usr/share/zoneinfo/America/New_York /etc/localtime\nsudo LC_ALL=en_US.UTF-8 add-apt-repository -y ppa:ondrej/php\nsudo apt update\nsudo apt install -yq apache2 php5.6 php5.6-mysql mysql-client\nsudo rm -rf /var/www/html/*\nsudo wget https://github.com/devopsdemoapps/devops-demo/raw/master/devops-demo.tar.gz\nsudo tar -xvzf devops-demo.tar.gz -C /var/www/html/\nsudo wget https://raw.githubusercontent.com/devopsdemoapps/devops-demo/master/devops-demo.sql\nsudo service apache2 restart\n\n\n\n\nfile: main.tf\n\n\n[...]\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \n${var.ami}\n\n  instance_type          = \n${var.instance[\ntype\n]}\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.webserver_sg.id}\n]\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \n${var.instance[\nname\n]}\n\n  }\n\n  provisioner \nfile\n {\n    source      = \nuser-data.sh\n\n    destination = \n/tmp/user-data.sh\n\n\n    connection {\n      type        = \nssh\n\n      user        = \n${var.ssh_user}\n\n      private_key = \n${file(var.ssh_pvtkey)}\n\n    }\n  }\n}\n[...]\n\n\n\n\nThis \nfile\n type provisioner copies the user-data from our local machine to the remote instance on \n/tmp/user-data.sh\n path. It requires authentication details to scp the file to the machine. Let us set the credentials in our \nvariables.tf\n file.\n\n\nfile: variables.tf\n\n\n[...]\nvariable \nssh_user\n {\n  default = \nubuntu\n\n}\n\nvariable \nssh_pvtkey\n {\n  default = \n~/.ssh/id_rsa\n\n}\n[...]\n\n\n\n\nWe will need to destroy and recreate the resources to apply this provisioner\n\n\nterraform destroy\n\n[output]\nDestroy complete! Resources: 3 destroyed.\n\n\n\n\nterraform apply\n\n[output]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Provisioning with 'file'...\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Still creating... (50s elapsed)\naws_instance.webserver: Still creating... (1m0s elapsed)\naws_instance.webserver: Still creating... (1m10s elapsed)\naws_instance.webserver: Creation complete after 1m11s (ID: i-02888bbc102c4d0ed)\n\nApply complete! Resources: 3 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 35.173.254.26\n\n\n\n\nRemote-Exec Provisioner\n\n\nNow we will execute the script that we have just copied over.\n\n\nfile: main.tf\n\n\nresource \naws_instance\n \nwebserver\n {\n  ami                    = \n${var.ami}\n\n  instance_type          = \n${var.instance[\ntype\n]}\n\n  key_name               = \nweb-admin-key\n\n  vpc_security_group_ids = [\n${aws_security_group.webserver_sg.id}\n]\n  depends_on             = [\naws_key_pair.webserver_key\n]\n\n  tags {\n    Name = \n${var.instance[\nname\n]}\n\n  }\n\n  provisioner \nfile\n {\n    source      = \nuser-data.sh\n\n    destination = \n/tmp/user-data.sh\n\n\n    connection {\n      type        = \nssh\n\n      user        = \n${var.ssh_user}\n\n      private_key = \n${file(var.ssh_pvtkey)}\n\n    }\n  }\n  provisioner \nremote-exec\n {\n    inline = [\n      \nchmod +x /tmp/user-data.sh\n,\n      \n/tmp/user-data.sh\n,\n    ]\n\n    connection {\n      type        = \nssh\n\n      user        = \n${var.ssh_user}\n\n      private_key = \n${file(var.ssh_pvtkey)}\n\n    }\n  }\n}\n\n\n\n\nWe will also add the ingress policy port \n80\n and egress policy for allo traffic in our security group.\n\n\nfile: main.tf\n\n\n[...]\nresource \naws_security_group\n \nwebserver_sg\n {\n  name = \nwebserver-sg\n\n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    = \ntcp\n\n    cidr_blocks = [\n0.0.0.0/0\n]\n  }\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    = \ntcp\n\n    cidr_blocks = [\n0.0.0.0/0\n]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    = \n-1\n\n    cidr_blocks = [\n0.0.0.0/0\n]\n  }\n}\n[...]\n\n\n\n\nFor this \nremote-exec\n provisioner to take effect, we need to recreate the resources(since these are creation-time provisoners).\n\n\nterraform destroy\n\n[output]\naws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 30s elapsed)\naws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 40s elapsed)\naws_instance.webserver: Destruction complete after 48s\naws_key_pair.webserver_key: Destroying... (ID: web-admin-key)\naws_security_group.webserver_sg: Destroying... (ID: sg-097c880ffd1c9f6c3)\naws_key_pair.webserver_key: Destruction complete after 1s\naws_security_group.webserver_sg: Destruction complete after 3s\n\nDestroy complete! Resources: 3 destroyed.\n\n\n\n\nterrform apply\n\n[output]\naws_instance.webserver (remote-exec): Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.200.133|:443... connected.\naws_instance.webserver (remote-exec): HTTP request sent, awaiting response... 200 OK\naws_instance.webserver (remote-exec): Length: 233 [text/plain]\naws_instance.webserver (remote-exec): Saving to: \u2018devops-demo.sql\u2019\n\naws_instance.webserver (remote-exec):  0%  0           --.-K/s\naws_instance.webserver (remote-exec): 100% 233         --.-K/s   in 0s\n\naws_instance.webserver (remote-exec): 2018-09-24 12:36:02 (9.54 MB/s) - \u2018devops-demo.sql\u2019 saved [233/233]\naws_instance.webserver: Creation complete after 5m11s (ID: i-02848bbc106c45ced)\n\nApply complete! Resources: 3 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 35.173.130.100\n\n\n\n\nOnce the creation is complete, you should be able to access the application by visiting the instance's public IP.\n\n\n\n\nReference\n\n\nFor more details about provisioners, please visit \nthis link\n.", 
            "title": "Provisioners in detail"
        }, 
        {
            "location": "/07-provisioners/#provisioners", 
            "text": "Provisioners are used to execute scripts either on local machines or on remote machines. \nProvisioners will run at either\n  1. Resource creation time , hence called  Creation-Time provisioner  or \n  2. Resource destruction time, hence called  Destroy-Time provisioner     Most generally used provisioners are, \n  * file        =  copy file from local to remote\n  * local-exec  =  execute on the machine where you run Terraform commands\n  * remote-exec =  execute on the machine created/modified by Terrform", 
            "title": "Provisioners"
        }, 
        {
            "location": "/07-provisioners/#devops-demo-application", 
            "text": "We will set up  this application  using creation-time provisioner.", 
            "title": "Devops Demo Application"
        }, 
        {
            "location": "/07-provisioners/#file-provisioner", 
            "text": "Create a new file with the name  user-data.sh  touch user-data.sh  file: user-data.sh  #!/bin/bash\nsudo apt update\nsudo apt install -y software-properties-common language-pack-en-base dialog apt-utils\nsudo update-locale LC_ALL=en_US.UTF-8 LANG=en_US.UTF-8\nsudo cp /usr/share/zoneinfo/America/New_York /etc/localtime\nsudo LC_ALL=en_US.UTF-8 add-apt-repository -y ppa:ondrej/php\nsudo apt update\nsudo apt install -yq apache2 php5.6 php5.6-mysql mysql-client\nsudo rm -rf /var/www/html/*\nsudo wget https://github.com/devopsdemoapps/devops-demo/raw/master/devops-demo.tar.gz\nsudo tar -xvzf devops-demo.tar.gz -C /var/www/html/\nsudo wget https://raw.githubusercontent.com/devopsdemoapps/devops-demo/master/devops-demo.sql\nsudo service apache2 restart  file: main.tf  [...]\nresource  aws_instance   webserver  {\n  ami                    =  ${var.ami} \n  instance_type          =  ${var.instance[ type ]} \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.webserver_sg.id} ]\n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  ${var.instance[ name ]} \n  }\n\n  provisioner  file  {\n    source      =  user-data.sh \n    destination =  /tmp/user-data.sh \n\n    connection {\n      type        =  ssh \n      user        =  ${var.ssh_user} \n      private_key =  ${file(var.ssh_pvtkey)} \n    }\n  }\n}\n[...]  This  file  type provisioner copies the user-data from our local machine to the remote instance on  /tmp/user-data.sh  path. It requires authentication details to scp the file to the machine. Let us set the credentials in our  variables.tf  file.  file: variables.tf  [...]\nvariable  ssh_user  {\n  default =  ubuntu \n}\n\nvariable  ssh_pvtkey  {\n  default =  ~/.ssh/id_rsa \n}\n[...]  We will need to destroy and recreate the resources to apply this provisioner  terraform destroy\n\n[output]\nDestroy complete! Resources: 3 destroyed.  terraform apply\n\n[output]\naws_instance.webserver: Still creating... (10s elapsed)\naws_instance.webserver: Still creating... (20s elapsed)\naws_instance.webserver: Still creating... (30s elapsed)\naws_instance.webserver: Provisioning with 'file'...\naws_instance.webserver: Still creating... (40s elapsed)\naws_instance.webserver: Still creating... (50s elapsed)\naws_instance.webserver: Still creating... (1m0s elapsed)\naws_instance.webserver: Still creating... (1m10s elapsed)\naws_instance.webserver: Creation complete after 1m11s (ID: i-02888bbc102c4d0ed)\n\nApply complete! Resources: 3 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 35.173.254.26", 
            "title": "File Provisioner"
        }, 
        {
            "location": "/07-provisioners/#remote-exec-provisioner", 
            "text": "Now we will execute the script that we have just copied over.  file: main.tf  resource  aws_instance   webserver  {\n  ami                    =  ${var.ami} \n  instance_type          =  ${var.instance[ type ]} \n  key_name               =  web-admin-key \n  vpc_security_group_ids = [ ${aws_security_group.webserver_sg.id} ]\n  depends_on             = [ aws_key_pair.webserver_key ]\n\n  tags {\n    Name =  ${var.instance[ name ]} \n  }\n\n  provisioner  file  {\n    source      =  user-data.sh \n    destination =  /tmp/user-data.sh \n\n    connection {\n      type        =  ssh \n      user        =  ${var.ssh_user} \n      private_key =  ${file(var.ssh_pvtkey)} \n    }\n  }\n  provisioner  remote-exec  {\n    inline = [\n       chmod +x /tmp/user-data.sh ,\n       /tmp/user-data.sh ,\n    ]\n\n    connection {\n      type        =  ssh \n      user        =  ${var.ssh_user} \n      private_key =  ${file(var.ssh_pvtkey)} \n    }\n  }\n}  We will also add the ingress policy port  80  and egress policy for allo traffic in our security group.  file: main.tf  [...]\nresource  aws_security_group   webserver_sg  {\n  name =  webserver-sg \n\n  ingress {\n    from_port   = 22\n    to_port     = 22\n    protocol    =  tcp \n    cidr_blocks = [ 0.0.0.0/0 ]\n  }\n\n  ingress {\n    from_port   = 80\n    to_port     = 80\n    protocol    =  tcp \n    cidr_blocks = [ 0.0.0.0/0 ]\n  }\n\n  egress {\n    from_port   = 0\n    to_port     = 0\n    protocol    =  -1 \n    cidr_blocks = [ 0.0.0.0/0 ]\n  }\n}\n[...]  For this  remote-exec  provisioner to take effect, we need to recreate the resources(since these are creation-time provisoners).  terraform destroy\n\n[output]\naws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 30s elapsed)\naws_instance.webserver: Still destroying... (ID: i-02888bbc102c4d0ed, 40s elapsed)\naws_instance.webserver: Destruction complete after 48s\naws_key_pair.webserver_key: Destroying... (ID: web-admin-key)\naws_security_group.webserver_sg: Destroying... (ID: sg-097c880ffd1c9f6c3)\naws_key_pair.webserver_key: Destruction complete after 1s\naws_security_group.webserver_sg: Destruction complete after 3s\n\nDestroy complete! Resources: 3 destroyed.  terrform apply\n\n[output]\naws_instance.webserver (remote-exec): Connecting to raw.githubusercontent.com (raw.githubusercontent.com)|151.101.200.133|:443... connected.\naws_instance.webserver (remote-exec): HTTP request sent, awaiting response... 200 OK\naws_instance.webserver (remote-exec): Length: 233 [text/plain]\naws_instance.webserver (remote-exec): Saving to: \u2018devops-demo.sql\u2019\n\naws_instance.webserver (remote-exec):  0%  0           --.-K/s\naws_instance.webserver (remote-exec): 100% 233         --.-K/s   in 0s\n\naws_instance.webserver (remote-exec): 2018-09-24 12:36:02 (9.54 MB/s) - \u2018devops-demo.sql\u2019 saved [233/233]\naws_instance.webserver: Creation complete after 5m11s (ID: i-02848bbc106c45ced)\n\nApply complete! Resources: 3 added, 0 changed, 0 destroyed.\n\nOutputs:\n\nwebserver_ip = 35.173.130.100  Once the creation is complete, you should be able to access the application by visiting the instance's public IP.", 
            "title": "Remote-Exec Provisioner"
        }, 
        {
            "location": "/07-provisioners/#reference", 
            "text": "For more details about provisioners, please visit  this link .", 
            "title": "Reference"
        }, 
        {
            "location": "/08-datasources/", 
            "text": "Data Source\n\n\nData sources are read only information that Terraform can get from Provider's API. When we use data source, Terraform doesn't create/modify anything. It just queries the API, so that the data can be used by other resources.\n\n\nLet us create a ELB which will loadbalance our application which we are gonna deploy in the next chapter.\n\n\nfile: main.tf\n\n\nresource \naws_elb\n \ndemo-elb\n {\n    name = \n}", 
            "title": "Data Sources"
        }, 
        {
            "location": "/08-datasources/#data-source", 
            "text": "Data sources are read only information that Terraform can get from Provider's API. When we use data source, Terraform doesn't create/modify anything. It just queries the API, so that the data can be used by other resources.  Let us create a ELB which will loadbalance our application which we are gonna deploy in the next chapter.  file: main.tf  resource  aws_elb   demo-elb  {\n    name = \n}", 
            "title": "Data Source"
        }, 
        {
            "location": "/09-terraform-state/", 
            "text": "Terraform State\n\n\nOne advantage, Terraform has over other configuration management tools like Ansible and Chef is State management. Terraform stores/tracks all our infrastructure information(that we have created using Terraform) in a file with the name \nterraform.tfstate\n. \n\n\nIn the last chapter, we have ran \nterraform apply\n. This command would create the above mentioned JSON flavoured statefile. Let us look at its the content.\n\n\nterraform.tfstate\n\n\n{\n    \nversion\n: 3,\n    \nterraform_version\n: \n0.11.7\n,\n    \nserial\n: 1,\n    \nlineage\n: \n138bb0c6-ca69-0d39-aa90-5e08f29c8efb\n,\n    \nmodules\n: [\n        {\n            \npath\n: [\n                \nroot\n\n            ],\n            \noutputs\n: {},\n            \nresources\n: {\n                \naws_instance.webserver\n: {\n                    \ntype\n: \naws_instance\n,\n                    \ndepends_on\n: [],\n                    \nprimary\n: {\n                        \nid\n: \ni-02489cdf638f05bbd\n,\n                        \nattributes\n: {\n                            \nami\n: \nami-408c7f28\n,\n                            \narn\n: \narn:aws:ec2:us-east-1:822941572458:instance/i-02489cdf638f05bbd\n,\n                            \nassociate_public_ip_address\n: \ntrue\n,\n                            \navailability_zone\n: \nus-east-1d\n,\n                            \ncpu_core_count\n: \n1\n,\n                            \ncpu_threads_per_core\n: \n1\n,\n                            \ncredit_specification.#\n: \n1\n,\n                            \ncredit_specification.0.cpu_credits\n: \nstandard\n,\n                            \ndisable_api_termination\n: \nfalse\n,\n                            \nebs_block_device.#\n: \n0\n,\n                            \nebs_optimized\n: \nfalse\n,\n                            \nephemeral_block_device.#\n: \n0\n,\n                            \nget_password_data\n: \nfalse\n,\n                            \niam_instance_profile\n: \n,\n                            \nid\n: \ni-02489cdf638f05bbd\n,\n                            \ninstance_state\n: \nrunning\n,\n                            \ninstance_type\n: \nt1.micro\n,\n                            \nipv6_addresses.#\n: \n0\n,\n                            \nkey_name\n: \n,\n                            \nmonitoring\n: \nfalse\n,\n                            \nnetwork_interface.#\n: \n0\n,\n                            \nnetwork_interface_id\n: \neni-00fbc08209349bb38\n,\n                            \npassword_data\n: \n,\n                            \nplacement_group\n: \n,\n                            \nprimary_network_interface_id\n: \neni-00fbc08209349bb38\n,\n                            \nprivate_dns\n: \nip-172-31-24-184.ec2.internal\n,\n                            \nprivate_ip\n: \n172.31.24.184\n,\n                            \npublic_dns\n: \nec2-34-230-78-138.compute-1.amazonaws.com\n,\n                            \npublic_ip\n: \n34.230.78.138\n,\n                            \nroot_block_device.#\n: \n1\n,\n                            \nroot_block_device.0.delete_on_termination\n: \ntrue\n,\n                            \nroot_block_device.0.iops\n: \n0\n,\n                            \nroot_block_device.0.volume_id\n: \nvol-0cc495c189e5c8dd2\n,\n                            \nroot_block_device.0.volume_size\n: \n8\n,\n                            \nroot_block_device.0.volume_type\n: \nstandard\n,\n                            \nsecurity_groups.#\n: \n1\n,\n                            \nsecurity_groups.3814588639\n: \ndefault\n,\n                            \nsource_dest_check\n: \ntrue\n,\n                            \nsubnet_id\n: \nsubnet-e8b3e6a2\n,\n                            \ntags.%\n: \n0\n,\n                            \ntenancy\n: \ndefault\n,\n                            \nvolume_tags.%\n: \n0\n,\n                            \nvpc_security_group_ids.#\n: \n1\n,\n                            \nvpc_security_group_ids.3314100969\n: \nsg-a42b7ae9\n\n                        },\n                        \nmeta\n: {\n                            \ne2bfb730-ecaa-11e6-8f88-34363bc7c4c0\n: {\n                                \ncreate\n: 600000000000,\n                                \ndelete\n: 1200000000000,\n                                \nupdate\n: 600000000000\n                            },\n                            \nschema_version\n: \n1\n\n                        },\n                        \ntainted\n: false\n                    },\n                    \ndeposed\n: [],\n                    \nprovider\n: \nprovider.aws\n\n                }\n            },\n            \ndepends_on\n: []\n        }\n    ]\n}\n\n\n\n\nUsecase 1\n\n\nThis file contains the metadata of our ec2 instance that we have created in the last chapter. This information will be critical when we have to create \nother resources which references this\n ec2 instance. As we add more resources to the terrform template, this file will get populated with more metadata about each resource.\n\n\nUsecase 2\n\n\nWhat happens when someone manually changes(which is not desirable) the properties of the instance created by Terraform? We can undo the manual changes just by running \nterraform apply\n again. One point to keep in mind though is, some property changes forces resource recreation which might result in data loss.\n\n\nChanges in Terrfaform state\n\n\nLet us see what happens to tfstate file when we destroy the ec2 instance\n\n\nterraform destroy\n\n[output]\naws_instance.webserver: Refreshing state... (ID: i-02489cdf638f05bbd)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n\nPlan: 0 to add, 0 to change, 1 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]\naws_instance.webserver: Still destroying... (ID: i-02489cdf638f05bbd, 1m0s elapsed)\naws_instance.webserver: Destruction complete after 1m0s\n\nDestroy complete! Resources: 1 destroyed.\n\n\n\n\nfile: terraform.tfstate\n\n\n{\n    \nversion\n: 3,\n    \nterraform_version\n: \n0.11.7\n,\n    \nserial\n: 2,\n    \nlineage\n: \n138bb0c6-ca69-0d39-aa90-5e08f29c8efb\n,\n    \nmodules\n: [\n        {\n            \npath\n: [\n                \nroot\n\n            ],\n            \noutputs\n: {},\n            \nresources\n: {},\n            \ndepends_on\n: []\n        }\n    ]\n}\n\n\n\n\nOnce the machine is destroyed, all metadata about that machine is also gone.\n\n\nReferences\n\n\nFor more information about state management in Terraform, please visit \nthis link\n.", 
            "title": "State Management in Terraform"
        }, 
        {
            "location": "/09-terraform-state/#terraform-state", 
            "text": "One advantage, Terraform has over other configuration management tools like Ansible and Chef is State management. Terraform stores/tracks all our infrastructure information(that we have created using Terraform) in a file with the name  terraform.tfstate .   In the last chapter, we have ran  terraform apply . This command would create the above mentioned JSON flavoured statefile. Let us look at its the content.  terraform.tfstate  {\n     version : 3,\n     terraform_version :  0.11.7 ,\n     serial : 1,\n     lineage :  138bb0c6-ca69-0d39-aa90-5e08f29c8efb ,\n     modules : [\n        {\n             path : [\n                 root \n            ],\n             outputs : {},\n             resources : {\n                 aws_instance.webserver : {\n                     type :  aws_instance ,\n                     depends_on : [],\n                     primary : {\n                         id :  i-02489cdf638f05bbd ,\n                         attributes : {\n                             ami :  ami-408c7f28 ,\n                             arn :  arn:aws:ec2:us-east-1:822941572458:instance/i-02489cdf638f05bbd ,\n                             associate_public_ip_address :  true ,\n                             availability_zone :  us-east-1d ,\n                             cpu_core_count :  1 ,\n                             cpu_threads_per_core :  1 ,\n                             credit_specification.# :  1 ,\n                             credit_specification.0.cpu_credits :  standard ,\n                             disable_api_termination :  false ,\n                             ebs_block_device.# :  0 ,\n                             ebs_optimized :  false ,\n                             ephemeral_block_device.# :  0 ,\n                             get_password_data :  false ,\n                             iam_instance_profile :  ,\n                             id :  i-02489cdf638f05bbd ,\n                             instance_state :  running ,\n                             instance_type :  t1.micro ,\n                             ipv6_addresses.# :  0 ,\n                             key_name :  ,\n                             monitoring :  false ,\n                             network_interface.# :  0 ,\n                             network_interface_id :  eni-00fbc08209349bb38 ,\n                             password_data :  ,\n                             placement_group :  ,\n                             primary_network_interface_id :  eni-00fbc08209349bb38 ,\n                             private_dns :  ip-172-31-24-184.ec2.internal ,\n                             private_ip :  172.31.24.184 ,\n                             public_dns :  ec2-34-230-78-138.compute-1.amazonaws.com ,\n                             public_ip :  34.230.78.138 ,\n                             root_block_device.# :  1 ,\n                             root_block_device.0.delete_on_termination :  true ,\n                             root_block_device.0.iops :  0 ,\n                             root_block_device.0.volume_id :  vol-0cc495c189e5c8dd2 ,\n                             root_block_device.0.volume_size :  8 ,\n                             root_block_device.0.volume_type :  standard ,\n                             security_groups.# :  1 ,\n                             security_groups.3814588639 :  default ,\n                             source_dest_check :  true ,\n                             subnet_id :  subnet-e8b3e6a2 ,\n                             tags.% :  0 ,\n                             tenancy :  default ,\n                             volume_tags.% :  0 ,\n                             vpc_security_group_ids.# :  1 ,\n                             vpc_security_group_ids.3314100969 :  sg-a42b7ae9 \n                        },\n                         meta : {\n                             e2bfb730-ecaa-11e6-8f88-34363bc7c4c0 : {\n                                 create : 600000000000,\n                                 delete : 1200000000000,\n                                 update : 600000000000\n                            },\n                             schema_version :  1 \n                        },\n                         tainted : false\n                    },\n                     deposed : [],\n                     provider :  provider.aws \n                }\n            },\n             depends_on : []\n        }\n    ]\n}", 
            "title": "Terraform State"
        }, 
        {
            "location": "/09-terraform-state/#usecase-1", 
            "text": "This file contains the metadata of our ec2 instance that we have created in the last chapter. This information will be critical when we have to create  other resources which references this  ec2 instance. As we add more resources to the terrform template, this file will get populated with more metadata about each resource.", 
            "title": "Usecase 1"
        }, 
        {
            "location": "/09-terraform-state/#usecase-2", 
            "text": "What happens when someone manually changes(which is not desirable) the properties of the instance created by Terraform? We can undo the manual changes just by running  terraform apply  again. One point to keep in mind though is, some property changes forces resource recreation which might result in data loss.", 
            "title": "Usecase 2"
        }, 
        {
            "location": "/09-terraform-state/#changes-in-terrfaform-state", 
            "text": "Let us see what happens to tfstate file when we destroy the ec2 instance  terraform destroy\n\n[output]\naws_instance.webserver: Refreshing state... (ID: i-02489cdf638f05bbd)\n\nAn execution plan has been generated and is shown below.\nResource actions are indicated with the following symbols:\n  - destroy\n\nTerraform will perform the following actions:\n\n  - aws_instance.webserver\n\n\nPlan: 0 to add, 0 to change, 1 to destroy.\n\nDo you really want to destroy?\n  Terraform will destroy all your managed infrastructure, as shown above.\n  There is no undo. Only 'yes' will be accepted to confirm.\n\n  Enter a value: yes\n  [...]\naws_instance.webserver: Still destroying... (ID: i-02489cdf638f05bbd, 1m0s elapsed)\naws_instance.webserver: Destruction complete after 1m0s\n\nDestroy complete! Resources: 1 destroyed.  file: terraform.tfstate  {\n     version : 3,\n     terraform_version :  0.11.7 ,\n     serial : 2,\n     lineage :  138bb0c6-ca69-0d39-aa90-5e08f29c8efb ,\n     modules : [\n        {\n             path : [\n                 root \n            ],\n             outputs : {},\n             resources : {},\n             depends_on : []\n        }\n    ]\n}  Once the machine is destroyed, all metadata about that machine is also gone.", 
            "title": "Changes in Terrfaform state"
        }, 
        {
            "location": "/09-terraform-state/#references", 
            "text": "For more information about state management in Terraform, please visit  this link .", 
            "title": "References"
        }, 
        {
            "location": "/10-backends/", 
            "text": "Backends\n\n\nCreate S3 Bucket\n\n\nFirst create a S3 bucket which is going store the state file. Enable \nversioning\n to enable state recovery if something goes wrong.\n\n\n\n\nCreate a directory called \ndev\n in that bucket.\n\n\n\n\ntouch backend.tf\n\n\n\n\nfile: backend.tf\n\n\nterraform {\n  backend \ns3\n {\n    bucket = \ndevopsdemo-tf-backend\n\n    key    = \n/dev\n\n    region = \nus-east-1\n\n  }\n}\n\n\n\n\nCreate DynamoDB Table for State Locking\n\n\n\n\nUpdate our backend file accordingly.\n\n\nfile: backend.tf\n\n\nterraform {\n  backend \ns3\n {\n    bucket         = \ndevopsdemo-tf-backend\n\n    key            = \ndev\n\n    region         = \nus-east-1\n\n    dynamodb_table = \ndevops-demo-table\n\n  }\n}\n\n\n\n\nInitialize the Backend\n\n\nterraform init\n\n[output]\nInitializing the backend...\nDo you want to copy existing state to the new backend?\n  Pre-existing state was found while migrating the previous \nlocal\n backend to the\n  newly configured \ns3\n backend. No existing state was found in the newly\n  configured \ns3\n backend. Do you want to copy this state to the new \ns3\n\n  backend? Enter \nyes\n to copy and \nno\n to start with an empty state.\n\n  Enter a value: yes\n\n\nSuccessfully configured the backend \ns3\n! Terraform will automatically\nuse this backend unless the backend configuration changes.\n\nInitializing provider plugins...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version = \n...\n constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version = \n~\n 1.37\n\n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running \nterraform plan\n to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.\n\n\n\n\nReference\n\n\nIf you want read more about AWS Remote Backends, follow \nthis link\n.", 
            "title": "Backend and Statelocking"
        }, 
        {
            "location": "/10-backends/#backends", 
            "text": "", 
            "title": "Backends"
        }, 
        {
            "location": "/10-backends/#create-s3-bucket", 
            "text": "First create a S3 bucket which is going store the state file. Enable  versioning  to enable state recovery if something goes wrong.   Create a directory called  dev  in that bucket.   touch backend.tf  file: backend.tf  terraform {\n  backend  s3  {\n    bucket =  devopsdemo-tf-backend \n    key    =  /dev \n    region =  us-east-1 \n  }\n}", 
            "title": "Create S3 Bucket"
        }, 
        {
            "location": "/10-backends/#create-dynamodb-table-for-state-locking", 
            "text": "Update our backend file accordingly.  file: backend.tf  terraform {\n  backend  s3  {\n    bucket         =  devopsdemo-tf-backend \n    key            =  dev \n    region         =  us-east-1 \n    dynamodb_table =  devops-demo-table \n  }\n}", 
            "title": "Create DynamoDB Table for State Locking"
        }, 
        {
            "location": "/10-backends/#initialize-the-backend", 
            "text": "terraform init\n\n[output]\nInitializing the backend...\nDo you want to copy existing state to the new backend?\n  Pre-existing state was found while migrating the previous  local  backend to the\n  newly configured  s3  backend. No existing state was found in the newly\n  configured  s3  backend. Do you want to copy this state to the new  s3 \n  backend? Enter  yes  to copy and  no  to start with an empty state.\n\n  Enter a value: yes\n\n\nSuccessfully configured the backend  s3 ! Terraform will automatically\nuse this backend unless the backend configuration changes.\n\nInitializing provider plugins...\n\nThe following providers do not have any version constraints in configuration,\nso the latest version was installed.\n\nTo prevent automatic upgrades to new major versions that may contain breaking\nchanges, it is recommended to add version =  ...  constraints to the\ncorresponding provider blocks in configuration, with the constraint strings\nsuggested below.\n\n* provider.aws: version =  ~  1.37 \n\nTerraform has been successfully initialized!\n\nYou may now begin working with Terraform. Try running  terraform plan  to see\nany changes that are required for your infrastructure. All Terraform commands\nshould now work.\n\nIf you ever set or change modules or backend configuration for Terraform,\nrerun this command to reinitialize your working directory. If you forget, other\ncommands will detect it and remind you to do so if necessary.", 
            "title": "Initialize the Backend"
        }, 
        {
            "location": "/10-backends/#reference", 
            "text": "If you want read more about AWS Remote Backends, follow  this link .", 
            "title": "Reference"
        }, 
        {
            "location": "/XX-course-outline/", 
            "text": "Goal in mind:\n=============\n  \u2022 Deploy Devops Demo app using Terraform\nOutline:\n========\n  \u2022 providers\n       |---set up credential for AWS provisioner\n       |---show how terraform init works\n  \u2022 backends \n       |---introduction to backends and state locking\n       |---show local state file\n       |---use s3+dynamo db as backend\n  \u2022 resources\n       |---create vpc and subnets\n       |---create one ec2 resource without variables\n  \u2022 variables \n outputs\n       |---introduction to variables\n       |---create RDS resource\n       |---parameterise ec2 template with variables(rds password, db name,user,pw, etc.,)\n       |---print public IP of ec2 instance, rdp endpoints, etc., with outputs\n  \u2022 data sources\n       |---introduction to data sources\n       |---use an existing AMI as reference(frontend installed)\n  \u2022 provisioners\n       |---introduction to provisioner\n       |---file provisioner to copy the script\n       |---remote-exec provisioner to execute the script(set up catalogue)\n  \u2022 modules\n       |---introduction to modules\n       |---create a module which contains ec2 template\n  \u2022 other useful terraform commands(graph, fmt, etc.,)\n  \u2022 terraform with Packer(demo)\n      |---creation of ami with packer\n      |---use that ami in terraform\n  \u2022 terraform with GCP(demo)\n      |---start with GCP provider\n      |---GCP backend setup\n      |---Deployment of mogambo Stack on GCP\n  \u2022 terraform with Azure(demo)\n     |---start with Azure provider\n     |---Azure backend setup\n     |---Deployment of mogambo Stack on Azure\n  \u2022 variable interpolation(conditionals) (advanced)\n  \u2022 terraform enterprise(advanced)\n  \u2022 import(advanced)\n  \u2022 templates(advanced)\n  \u2022 plugin development(advanced)", 
            "title": "Course Outline"
        }
    ]
}